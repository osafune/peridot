
peridot_testsuite.elf:     file format elf32-littlenios2
peridot_testsuite.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0f000020

Program Header:
    LOAD off    0x00001000 vaddr 0x0f000000 paddr 0x0f000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x0f000020 paddr 0x0f000020 align 2**12
         filesz 0x000016dc memsz 0x000016dc flags r-x
    LOAD off    0x000026fc vaddr 0x0f0016fc paddr 0x0f0017ec align 2**12
         filesz 0x000000f0 memsz 0x000000f0 flags rw-
    LOAD off    0x000028dc vaddr 0x0f0018dc paddr 0x0f0018dc align 2**12
         filesz 0x00000000 memsz 0x00000010 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  0f000000  0f000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         000014b0  0f000020  0f000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000022c  0f0014d0  0f0014d0  000024d0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rwdata       000000f0  0f0016fc  0f0017ec  000026fc  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  4 .bss          00000010  0f0018dc  0f0018dc  000028dc  2**2
                  ALLOC, SMALL_DATA
  5 .comment      00000023  00000000  00000000  000027ec  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000310  00000000  00000000  00002810  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00005653  00000000  00000000  00002b20  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000019ef  00000000  00000000  00008173  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001fd6  00000000  00000000  00009b62  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000003f0  00000000  00000000  0000bb38  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001148  00000000  00000000  0000bf28  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001e1e  00000000  00000000  0000d070  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_alt_sim_info 00000010  00000000  00000000  0000ee90  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000268  00000000  00000000  0000eea0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .thread_model 00000003  00000000  00000000  000102e5  2**0
                  CONTENTS, READONLY
 16 .cpu          00000007  00000000  00000000  000102e8  2**0
                  CONTENTS, READONLY
 17 .qsys         00000001  00000000  00000000  000102ef  2**0
                  CONTENTS, READONLY
 18 .simulation_enabled 00000001  00000000  00000000  000102f0  2**0
                  CONTENTS, READONLY
 19 .sysid_hash   00000004  00000000  00000000  000102f1  2**0
                  CONTENTS, READONLY
 20 .sysid_base   00000004  00000000  00000000  000102f5  2**0
                  CONTENTS, READONLY
 21 .sysid_time   00000004  00000000  00000000  000102f9  2**0
                  CONTENTS, READONLY
 22 .stderr_dev   00000009  00000000  00000000  000102fd  2**0
                  CONTENTS, READONLY
 23 .stdin_dev    00000009  00000000  00000000  00010306  2**0
                  CONTENTS, READONLY
 24 .stdout_dev   00000009  00000000  00000000  0001030f  2**0
                  CONTENTS, READONLY
 25 .sopc_system_name 00000008  00000000  00000000  00010318  2**0
                  CONTENTS, READONLY
 26 .quartus_project_dir 00000039  00000000  00000000  00010320  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     0005c518  00000000  00000000  00010359  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
0f000000 l    d  .entry	00000000 .entry
0f000020 l    d  .text	00000000 .text
0f0014d0 l    d  .rodata	00000000 .rodata
0f0016fc l    d  .rwdata	00000000 .rwdata
0f0018dc l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../peridot_testsuite_bsp//obj/HAL/src/crt0.o
0f000058 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 memtest_small.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
0f0016fc l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
0f0010cc l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 
0f000694 g     F .text	0000001c putchar
0f001300 g     F .text	0000002c alt_main
0f0006b0 g     F .text	00000080 _puts_r
0f0017ec g       *ABS*	00000000 __flash_rwdata_start
0f000640 g     F .text	0000004c printf
0f0017e4 g     O .rwdata	00000004 jtag_uart
00000000  w      *UND*	00000000 __errno
0f000000 g     F .entry	0000000c __reset
0f000020 g       *ABS*	00000000 __flash_exceptions_start
0f0018dc g     O .bss	00000004 errno
0f0018e4 g     O .bss	00000004 alt_argv
0f0097dc g       *ABS*	00000000 _gp
0f00068c g     F .text	00000008 _putchar_r
0f0005dc g     F .text	00000028 memcpy
0f000730 g     F .text	00000014 puts
0f000604 g     F .text	0000003c _printf_r
0f0011ec g     F .text	00000008 __udivsi3
0f0017dc g     O .rwdata	00000004 _global_impure_ptr
0f0018ec g       *ABS*	00000000 __bss_end
0f0014c0 g     F .text	00000004 alt_dcache_flush_all
0f0017ec g       *ABS*	00000000 __ram_rwdata_end
0f00132c g     F .text	00000068 write
0f001000 g     F .text	00000060 _putc_r
0f0016fc g       *ABS*	00000000 __ram_rodata_end
0f0011f4 g     F .text	00000008 __umodsi3
0f0018ec g       *ABS*	00000000 end
0f004000 g       *ABS*	00000000 __alt_stack_pointer
0f0013b8 g     F .text	00000034 altera_avalon_jtag_uart_write
0f00076c g     F .text	00000734 ___vfprintf_internal_r
0f000020 g     F .text	0000003c _start
0f0013ec g     F .text	000000d4 alt_avalon_spi_command
0f0013b4 g     F .text	00000004 alt_sys_init
0f0005b4 g     F .text	00000028 __mulsi3
0f0016fc g       *ABS*	00000000 __ram_rwdata_start
0f0014d0 g       *ABS*	00000000 __ram_rodata_start
0f0018ec g       *ABS*	00000000 __alt_stack_base
0f000ec4 g     F .text	000000e0 __sfvwrite_small_dev
0f0018dc g       *ABS*	00000000 __bss_start
0f00005c g     F .text	00000558 main
0f0018e0 g     O .bss	00000004 alt_envp
0f0017e8 g     O .rwdata	00000004 alt_errno
0f000fa4 g     F .text	0000005c putc
0f001140 g     F .text	00000050 __divsi3
0f0014d0 g       *ABS*	00000000 __flash_rodata_start
0f001394 g     F .text	00000020 alt_irq_init
0f001060 g     F .text	0000006c _write_r
0f0017e0 g     O .rwdata	00000004 _impure_ptr
0f0018e8 g     O .bss	00000004 alt_argc
0f000020 g       *ABS*	00000000 __ram_exceptions_start
0f0017ec g       *ABS*	00000000 _edata
0f0018ec g       *ABS*	00000000 _end
0f000020 g       *ABS*	00000000 __ram_exceptions_end
0f0014c8 g     F .text	00000008 altera_nios2_qsys_irq_init
0f001190 g     F .text	0000005c __modsi3
0f004000 g       *ABS*	00000000 __alt_data_end
00000000 g       *ABS*	00000000 __alt_mem_sdram
0f00000c g       .entry	00000000 _exit
0f000000 g       *ABS*	00000000 __alt_mem_ipl_memory
0f000744 g     F .text	00000028 strlen
0f0014c4 g     F .text	00000004 alt_icache_flush_all
0f000ea0 g     F .text	00000024 __vfprintf_internal
0f0011fc g     F .text	00000104 alt_load



Disassembly of section .entry:

0f000000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 f000000:	0043c034 	movhi	at,3840
    ori r1, r1, %lo(_start)
 f000004:	08400814 	ori	at,at,32
    jmp r1
 f000008:	0800683a 	jmp	at

0f00000c <_exit>:
	...

Disassembly of section .text:

0f000020 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 f000020:	06c3c034 	movhi	sp,3840
    ori sp, sp, %lo(__alt_stack_pointer)
 f000024:	ded00014 	ori	sp,sp,16384
    movhi gp, %hi(_gp)
 f000028:	0683c034 	movhi	gp,3840
    ori gp, gp, %lo(_gp)
 f00002c:	d6a5f714 	ori	gp,gp,38876
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 f000030:	0083c034 	movhi	r2,3840
    ori r2, r2, %lo(__bss_start)
 f000034:	10863714 	ori	r2,r2,6364

    movhi r3, %hi(__bss_end)
 f000038:	00c3c034 	movhi	r3,3840
    ori r3, r3, %lo(__bss_end)
 f00003c:	18c63b14 	ori	r3,r3,6380

    beq r2, r3, 1f
 f000040:	10c00326 	beq	r2,r3,f000050 <_start+0x30>

0:
    stw zero, (r2)
 f000044:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 f000048:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 f00004c:	10fffd36 	bltu	r2,r3,f000044 <_gp+0xffff6868>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 f000050:	f0011fc0 	call	f0011fc <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 f000054:	f0013000 	call	f001300 <alt_main>

0f000058 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 f000058:	003fff06 	br	f000058 <_gp+0xffff687c>

0f00005c <main>:
	return 0;
}


int main(void)
{
 f00005c:	deffd904 	addi	sp,sp,-156
 f000060:	dc802115 	stw	r18,132(sp)
 f000064:	dfc02615 	stw	ra,152(sp)
 f000068:	dd802515 	stw	r22,148(sp)
 f00006c:	dd402415 	stw	r21,144(sp)
 f000070:	dd002315 	stw	r20,140(sp)
 f000074:	dcc02215 	stw	r19,136(sp)
 f000078:	dc402015 	stw	r17,128(sp)
 f00007c:	dc001f15 	stw	r16,124(sp)
	IOWR(LED_BASE, 0, 0);	// LED消灯 
 f000080:	04840034 	movhi	r18,4096
 f000084:	94804004 	addi	r18,r18,256
 f000088:	90000035 	stwio	zero,0(r18)
	memory_base = SDRAM_BASE;
	memory_end = SDRAM_BASE + SDRAM_SPAN - 1;

  memory_size = (memory_end - memory_base);

  printf("\n");
 f00008c:	01000284 	movi	r4,10
 f000090:	f0006940 	call	f000694 <putchar>
  printf("Testing RAM from 0x%X to 0x%X\n", memory_base, (memory_base + memory_size));
 f000094:	000b883a 	mov	r5,zero
 f000098:	0103c034 	movhi	r4,3840
 f00009c:	21053404 	addi	r4,r4,5328
 f0000a0:	01802034 	movhi	r6,128
 f0000a4:	31bfffc4 	addi	r6,r6,-1
 f0000a8:	f0006400 	call	f000640 <printf>
{
  unsigned int pattern;
  unsigned int ret_code = 0x0;

  /* Perform a walking 1's test at the given address. */
  for (pattern = 1; pattern != 0; pattern <<= 1)
 f0000ac:	01400044 	movi	r5,1
  {
    /* Write the test pattern. */
    IOWR_32DIRECT(address, 0, pattern);
 f0000b0:	0005883a 	mov	r2,zero
 f0000b4:	11400035 	stwio	r5,0(r2)

    /* Read it back (immediately is okay for this test). */
    if (IORD_32DIRECT(address, 0) != pattern)
 f0000b8:	10c00037 	ldwio	r3,0(r2)
 f0000bc:	1940031e 	bne	r3,r5,f0000cc <main+0x70>
{
  unsigned int pattern;
  unsigned int ret_code = 0x0;

  /* Perform a walking 1's test at the given address. */
  for (pattern = 1; pattern != 0; pattern <<= 1)
 f0000c0:	294b883a 	add	r5,r5,r5
 f0000c4:	283ffb1e 	bne	r5,zero,f0000b4 <_gp+0xffff68d8>
 f0000c8:	00000406 	br	f0000dc <main+0x80>
  printf("Testing RAM from 0x%X to 0x%X\n", memory_base, (memory_base + memory_size));

  /* Test Data Bus. */
  ret_code = MemTestDataBus(memory_base);

  if (ret_code)
 f0000cc:	28000326 	beq	r5,zero,f0000dc <main+0x80>
   printf(" -Data bus test failed at bit 0x%X", (int)ret_code);
 f0000d0:	0103c034 	movhi	r4,3840
 f0000d4:	21053c04 	addi	r4,r4,5360
 f0000d8:	0000a906 	br	f000380 <main+0x324>
  else
    printf(" -Data bus test passed\n");
 f0000dc:	0103c034 	movhi	r4,3840
 f0000e0:	21054504 	addi	r4,r4,5396
 f0000e4:	f0007300 	call	f000730 <puts>
 f0000e8:	00800584 	movi	r2,22
 f0000ec:	00c00104 	movi	r3,4
 f0000f0:	016aaaf4 	movhi	r5,43691
 f0000f4:	296aaa84 	addi	r5,r5,-21846
 f0000f8:	00000206 	br	f000104 <main+0xa8>
  unsigned int ret_code = 0x0;

  /* Write the default pattern at each of the power-of-two offsets. */
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
  {
    IOWR_32DIRECT(memory_base, offset, pattern);
 f0000fc:	19400035 	stwio	r5,0(r3)
  unsigned int antipattern  = 0x55555555;

  unsigned int ret_code = 0x0;

  /* Write the default pattern at each of the power-of-two offsets. */
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 f000100:	18c7883a 	add	r3,r3,r3
 f000104:	10bfffc4 	addi	r2,r2,-1
 f000108:	012aaaf4 	movhi	r4,43691
 f00010c:	212aaa84 	addi	r4,r4,-21846
 f000110:	103ffa1e 	bne	r2,zero,f0000fc <_gp+0xffff6920>
    IOWR_32DIRECT(memory_base, offset, pattern);
  }

  /* Check for address bits stuck high. */
  test_offset = 0;
  IOWR_32DIRECT(memory_base, test_offset, antipattern);
 f000114:	00d55574 	movhi	r3,21845
 f000118:	18d55544 	addi	r3,r3,21845
 f00011c:	10c00035 	stwio	r3,0(r2)
 f000120:	00800584 	movi	r2,22
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 f000124:	04000104 	movi	r16,4
 f000128:	180f883a 	mov	r7,r3
 f00012c:	00000306 	br	f00013c <main+0xe0>
  {
     if (IORD_32DIRECT(memory_base, offset) != pattern)
 f000130:	80c00037 	ldwio	r3,0(r16)
 f000134:	1900041e 	bne	r3,r4,f000148 <main+0xec>
  }

  /* Check for address bits stuck high. */
  test_offset = 0;
  IOWR_32DIRECT(memory_base, test_offset, antipattern);
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 f000138:	8421883a 	add	r16,r16,r16
 f00013c:	10bfffc4 	addi	r2,r2,-1
 f000140:	103ffb1e 	bne	r2,zero,f000130 <_gp+0xffff6954>
  unsigned int test_offset;

  unsigned int pattern     = 0xAAAAAAAA;
  unsigned int antipattern  = 0x55555555;

  unsigned int ret_code = 0x0;
 f000144:	0021883a 	mov	r16,zero
        break;
     }
  }

  /* Check for address bits stuck low or shorted. */
  IOWR_32DIRECT(memory_base, test_offset, pattern);
 f000148:	0005883a 	mov	r2,zero
 f00014c:	11000035 	stwio	r4,0(r2)
 f000150:	01400584 	movi	r5,22
  for (test_offset = sizeof(unsigned int); (test_offset & address_mask) != 0; test_offset <<= 1)
 f000154:	00800104 	movi	r2,4
 f000158:	00000f06 	br	f000198 <main+0x13c>
  {
    if (!ret_code)
 f00015c:	80000d1e 	bne	r16,zero,f000194 <main+0x138>
    {
      IOWR_32DIRECT(memory_base, test_offset, antipattern);
 f000160:	11c00035 	stwio	r7,0(r2)
 f000164:	01800584 	movi	r6,22
      for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 f000168:	00c00104 	movi	r3,4
 f00016c:	00000406 	br	f000180 <main+0x124>
      {
        if ((IORD_32DIRECT(memory_base, offset) != pattern) && (offset != test_offset))
 f000170:	1a000037 	ldwio	r8,0(r3)
 f000174:	41000126 	beq	r8,r4,f00017c <main+0x120>
 f000178:	1880041e 	bne	r3,r2,f00018c <main+0x130>
  for (test_offset = sizeof(unsigned int); (test_offset & address_mask) != 0; test_offset <<= 1)
  {
    if (!ret_code)
    {
      IOWR_32DIRECT(memory_base, test_offset, antipattern);
      for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 f00017c:	18c7883a 	add	r3,r3,r3
 f000180:	31bfffc4 	addi	r6,r6,-1
 f000184:	303ffa1e 	bne	r6,zero,f000170 <_gp+0xffff6994>
 f000188:	00000106 	br	f000190 <main+0x134>
      {
        if ((IORD_32DIRECT(memory_base, offset) != pattern) && (offset != test_offset))
 f00018c:	1021883a 	mov	r16,r2
        {
          ret_code = (memory_base + test_offset);
          break;
        }
      }
      IOWR_32DIRECT(memory_base, test_offset, pattern);
 f000190:	11000035 	stwio	r4,0(r2)
     }
  }

  /* Check for address bits stuck low or shorted. */
  IOWR_32DIRECT(memory_base, test_offset, pattern);
  for (test_offset = sizeof(unsigned int); (test_offset & address_mask) != 0; test_offset <<= 1)
 f000194:	1085883a 	add	r2,r2,r2
 f000198:	297fffc4 	addi	r5,r5,-1
 f00019c:	283fef1e 	bne	r5,zero,f00015c <_gp+0xffff6980>

  /* Test Address Bus. */
  if (!ret_code)
  {
    ret_code  = MemTestAddressBus(memory_base, memory_size);
    if  (ret_code)
 f0001a0:	80000326 	beq	r16,zero,f0001b0 <main+0x154>
      printf(" -Address bus test failed at address 0x%X", (int)ret_code);
 f0001a4:	0103c034 	movhi	r4,3840
 f0001a8:	21054b04 	addi	r4,r4,5420
 f0001ac:	00006c06 	br	f000360 <main+0x304>
    else
      printf(" -Address bus test passed\n");
 f0001b0:	0103c034 	movhi	r4,3840
 f0001b4:	21055604 	addi	r4,r4,5464
 f0001b8:	f0007300 	call	f000730 <puts>
static int MemTest8_16BitAccess(unsigned int memory_base)
{
  int ret_code = 0x0;

  /* Write 4 bytes */
  IOWR_8DIRECT(memory_base, 0, 0x0A);
 f0001bc:	00800284 	movi	r2,10
 f0001c0:	80800025 	stbio	r2,0(r16)
  IOWR_8DIRECT(memory_base, 1, 0x05);
 f0001c4:	00800044 	movi	r2,1
 f0001c8:	00c00144 	movi	r3,5
 f0001cc:	10c00025 	stbio	r3,0(r2)
  IOWR_8DIRECT(memory_base, 2, 0xA0);
 f0001d0:	00800084 	movi	r2,2
 f0001d4:	00ffe804 	movi	r3,-96
 f0001d8:	10c00025 	stbio	r3,0(r2)
  IOWR_8DIRECT(memory_base, 3, 0x50);
 f0001dc:	00c000c4 	movi	r3,3
 f0001e0:	01001404 	movi	r4,80
 f0001e4:	19000025 	stbio	r4,0(r3)

  /* Read it back as one word */
  if(IORD_32DIRECT(memory_base, 0) != 0x50A0050A)
 f0001e8:	81000037 	ldwio	r4,0(r16)
  }

  /* Read it back as two half-words */
  if (!ret_code)
  {
    if ((IORD_16DIRECT(memory_base, 2) != 0x50A0) ||
 f0001ec:	1140002b 	ldhuio	r5,0(r2)
 f0001f0:	01142804 	movi	r4,20640
 f0001f4:	297fffcc 	andi	r5,r5,65535
 f0001f8:	2900011e 	bne	r5,r4,f000200 <main+0x1a4>
        (IORD_16DIRECT(memory_base, 0) != 0x050A))
 f0001fc:	8100002b 	ldhuio	r4,0(r16)
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
 f000200:	19000023 	ldbuio	r4,0(r3)
 f000204:	00c01404 	movi	r3,80
 f000208:	21003fcc 	andi	r4,r4,255
 f00020c:	20c00b1e 	bne	r4,r3,f00023c <main+0x1e0>
        (IORD_8DIRECT(memory_base, 2) != 0xA0) ||
 f000210:	10c00023 	ldbuio	r3,0(r2)
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
 f000214:	00802804 	movi	r2,160
        (IORD_8DIRECT(memory_base, 2) != 0xA0) ||
 f000218:	18c03fcc 	andi	r3,r3,255
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
 f00021c:	1880071e 	bne	r3,r2,f00023c <main+0x1e0>
        (IORD_8DIRECT(memory_base, 2) != 0xA0) ||
        (IORD_8DIRECT(memory_base, 1) != 0x05) ||
 f000220:	00800044 	movi	r2,1
 f000224:	10c00023 	ldbuio	r3,0(r2)

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
        (IORD_8DIRECT(memory_base, 2) != 0xA0) ||
 f000228:	00800144 	movi	r2,5
        (IORD_8DIRECT(memory_base, 1) != 0x05) ||
 f00022c:	18c03fcc 	andi	r3,r3,255

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
        (IORD_8DIRECT(memory_base, 2) != 0xA0) ||
 f000230:	1880021e 	bne	r3,r2,f00023c <main+0x1e0>
        (IORD_8DIRECT(memory_base, 1) != 0x05) ||
        (IORD_8DIRECT(memory_base, 0) != 0x0A))
 f000234:	0005883a 	mov	r2,zero
 f000238:	10800023 	ldbuio	r2,0(r2)
  }

  /* Write 2 half-words */
  if (!ret_code)
  {
    IOWR_16DIRECT(memory_base, 0, 0x50A0);
 f00023c:	0005883a 	mov	r2,zero
 f000240:	00d42804 	movi	r3,20640
 f000244:	10c0002d 	sthio	r3,0(r2)
    IOWR_16DIRECT(memory_base, 2, 0x050A);
 f000248:	00c00084 	movi	r3,2
 f00024c:	01014284 	movi	r4,1290
 f000250:	1900002d 	sthio	r4,0(r3)

    /* Read it back as one word */
    if(IORD_32DIRECT(memory_base, 0) != 0x050A50A0)
 f000254:	11000037 	ldwio	r4,0(r2)
  }

  /* Read it back as two half-words */
  if (!ret_code)
  {
    if ((IORD_16DIRECT(memory_base, 2) != 0x050A) ||
 f000258:	1940002b 	ldhuio	r5,0(r3)
 f00025c:	01014284 	movi	r4,1290
 f000260:	297fffcc 	andi	r5,r5,65535
 f000264:	2900011e 	bne	r5,r4,f00026c <main+0x210>
        (IORD_16DIRECT(memory_base, 0) != 0x50A0))
 f000268:	1080002b 	ldhuio	r2,0(r2)
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
 f00026c:	008000c4 	movi	r2,3
 f000270:	11000023 	ldbuio	r4,0(r2)
 f000274:	00800144 	movi	r2,5
 f000278:	21003fcc 	andi	r4,r4,255
 f00027c:	20800b1e 	bne	r4,r2,f0002ac <main+0x250>
        (IORD_8DIRECT(memory_base, 2) != 0x0A) ||
 f000280:	18c00023 	ldbuio	r3,0(r3)
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
 f000284:	00800284 	movi	r2,10
        (IORD_8DIRECT(memory_base, 2) != 0x0A) ||
 f000288:	18c03fcc 	andi	r3,r3,255
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
 f00028c:	1880071e 	bne	r3,r2,f0002ac <main+0x250>
        (IORD_8DIRECT(memory_base, 2) != 0x0A) ||
        (IORD_8DIRECT(memory_base, 1) != 0x50) ||
 f000290:	00800044 	movi	r2,1
 f000294:	10c00023 	ldbuio	r3,0(r2)

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
        (IORD_8DIRECT(memory_base, 2) != 0x0A) ||
 f000298:	00801404 	movi	r2,80
        (IORD_8DIRECT(memory_base, 1) != 0x50) ||
 f00029c:	18c03fcc 	andi	r3,r3,255

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
        (IORD_8DIRECT(memory_base, 2) != 0x0A) ||
 f0002a0:	1880021e 	bne	r3,r2,f0002ac <main+0x250>
        (IORD_8DIRECT(memory_base, 1) != 0x50) ||
        (IORD_8DIRECT(memory_base, 0) != 0xA0))
 f0002a4:	0005883a 	mov	r2,zero
 f0002a8:	10800023 	ldbuio	r2,0(r2)
  {
    ret_code = MemTest8_16BitAccess(memory_base);
    if  (ret_code)
      printf(" -Byte and half-word access test failed at address 0x%X", (int)ret_code);
    else
      printf(" -Byte and half-word access test passed\n");
 f0002ac:	0103c034 	movhi	r4,3840
 f0002b0:	21055d04 	addi	r4,r4,5492
 f0002b4:	f0007300 	call	f000730 <puts>
  }

  /* Test that each bit in the device can store both 1 and 0. */
  if (!ret_code)
  {
    printf(" -Testing each bit in memory device.");
 f0002b8:	0103c034 	movhi	r4,3840
 f0002bc:	21056704 	addi	r4,r4,5532
 f0002c0:	f0006400 	call	f000640 <printf>
  unsigned int pattern;
  unsigned int antipattern;
  unsigned int ret_code = 0x0;

  /* Fill memory with a known pattern. */
  for (pattern = 1, offset = 0; offset < nBytes; pattern++, offset+=4)
 f0002c4:	00800044 	movi	r2,1
 f0002c8:	01000834 	movhi	r4,32
 f0002cc:	21000044 	addi	r4,r4,1

	return 0;
}


int main(void)
 f0002d0:	1087883a 	add	r3,r2,r2
 f0002d4:	18c7883a 	add	r3,r3,r3
  unsigned int ret_code = 0x0;

  /* Fill memory with a known pattern. */
  for (pattern = 1, offset = 0; offset < nBytes; pattern++, offset+=4)
  {
    IOWR_32DIRECT(memory_base, offset, pattern);
 f0002d8:	18bfff35 	stwio	r2,-4(r3)
  unsigned int pattern;
  unsigned int antipattern;
  unsigned int ret_code = 0x0;

  /* Fill memory with a known pattern. */
  for (pattern = 1, offset = 0; offset < nBytes; pattern++, offset+=4)
 f0002dc:	10800044 	addi	r2,r2,1
 f0002e0:	113ffb1e 	bne	r2,r4,f0002d0 <_gp+0xffff6af4>
  {
    IOWR_32DIRECT(memory_base, offset, pattern);
  }

  printf(" .");
 f0002e4:	0103c034 	movhi	r4,3840
 f0002e8:	21057104 	addi	r4,r4,5572
 f0002ec:	f0006400 	call	f000640 <printf>

  /* Check each location and invert it for the second pass. */
  for (pattern = 1, offset = 0; offset < nBytes; pattern++, offset+=4)
 f0002f0:	00800044 	movi	r2,1
 f0002f4:	0021883a 	mov	r16,zero
 f0002f8:	00c02034 	movhi	r3,128
  {
    if (IORD_32DIRECT(memory_base, offset) != pattern)
 f0002fc:	81000037 	ldwio	r4,0(r16)
 f000300:	2080061e 	bne	r4,r2,f00031c <main+0x2c0>
    {
      ret_code = (memory_base + offset);
      break;
    }
    antipattern = ~pattern;
 f000304:	0088303a 	nor	r4,zero,r2
    IOWR_32DIRECT(memory_base, offset, antipattern);
 f000308:	81000035 	stwio	r4,0(r16)
  }

  printf(" .");

  /* Check each location and invert it for the second pass. */
  for (pattern = 1, offset = 0; offset < nBytes; pattern++, offset+=4)
 f00030c:	84000104 	addi	r16,r16,4
 f000310:	10800044 	addi	r2,r2,1
 f000314:	80fff91e 	bne	r16,r3,f0002fc <_gp+0xffff6b20>
static int MemTestDevice(unsigned int memory_base, unsigned int nBytes)
{
  unsigned int offset;
  unsigned int pattern;
  unsigned int antipattern;
  unsigned int ret_code = 0x0;
 f000318:	0021883a 	mov	r16,zero
    }
    antipattern = ~pattern;
    IOWR_32DIRECT(memory_base, offset, antipattern);
  }

  printf(" .");
 f00031c:	0103c034 	movhi	r4,3840
 f000320:	21057104 	addi	r4,r4,5572
 f000324:	f0006400 	call	f000640 <printf>
 f000328:	00ffff84 	movi	r3,-2

  /* Check each location for the inverted pattern and zero it. */
  for (pattern = 1, offset = 0; offset < nBytes; pattern++, offset+=4)
 f00032c:	0005883a 	mov	r2,zero
 f000330:	01002034 	movhi	r4,128
  {
    antipattern = ~pattern;
    if (IORD_32DIRECT(memory_base, offset) != antipattern)
 f000334:	11400037 	ldwio	r5,0(r2)
 f000338:	28c0051e 	bne	r5,r3,f000350 <main+0x2f4>
    {
      ret_code = (memory_base + offset);
      break;
    }
    IOWR_32DIRECT(memory_base, offset, 0x0);
 f00033c:	10000035 	stwio	zero,0(r2)
  }

  printf(" .");

  /* Check each location for the inverted pattern and zero it. */
  for (pattern = 1, offset = 0; offset < nBytes; pattern++, offset+=4)
 f000340:	10800104 	addi	r2,r2,4
 f000344:	18ffffc4 	addi	r3,r3,-1
 f000348:	113ffa1e 	bne	r2,r4,f000334 <_gp+0xffff6b58>
 f00034c:	00000106 	br	f000354 <main+0x2f8>
  {
    antipattern = ~pattern;
    if (IORD_32DIRECT(memory_base, offset) != antipattern)
 f000350:	1021883a 	mov	r16,r2
  /* Test that each bit in the device can store both 1 and 0. */
  if (!ret_code)
  {
    printf(" -Testing each bit in memory device.");
    ret_code = MemTestDevice(memory_base, memory_size);
    if  (ret_code)
 f000354:	80000426 	beq	r16,zero,f000368 <main+0x30c>
      printf("  failed at address 0x%X", (int)ret_code);
 f000358:	0103c034 	movhi	r4,3840
 f00035c:	21057204 	addi	r4,r4,5576
 f000360:	800b883a 	mov	r5,r16
 f000364:	00000606 	br	f000380 <main+0x324>
    else
      printf("  passed\n");
 f000368:	0103c034 	movhi	r4,3840
 f00036c:	21057904 	addi	r4,r4,5604
 f000370:	f0007300 	call	f000730 <puts>
  }


	if (!ret_code) {
		printf("Memory at 0x%X Okay\n", memory_base);
 f000374:	0103c034 	movhi	r4,3840
 f000378:	21057c04 	addi	r4,r4,5616
 f00037c:	000b883a 	mov	r5,zero
 f000380:	f0006400 	call	f000640 <printf>

static int TestRam(void);

static int TestPio(void) {
	const int pionum = 13;	// D15とD14は省略 
	const int portoutbit[14] = {0, 27, 2, 25, 4, 23, 6, 21, 9, 19, 11, 17, 13, 15};
 f000384:	d9001104 	addi	r4,sp,68
 f000388:	0143c034 	movhi	r5,3840
 f00038c:	2945a304 	addi	r5,r5,5772
 f000390:	01800e04 	movi	r6,56
 f000394:	f0005dc0 	call	f0005dc <memcpy>
	const int portinbit[14] =  {7, 1, 26, 3, 24, 5, 22, 8, 20, 10, 18, 12, 16, 14};
 f000398:	d9000304 	addi	r4,sp,12
 f00039c:	01800e04 	movi	r6,56
 f0003a0:	0143c034 	movhi	r5,3840
 f0003a4:	2945b104 	addi	r5,r5,5828
 f0003a8:	f0005dc0 	call	f0005dc <memcpy>
 f0003ac:	0005883a 	mov	r2,zero

	alt_u32 readbitmask = 0;
	alt_u32 portdir = 0;
 f0003b0:	0007883a 	mov	r3,zero
	alt_u32 pattern, check;
	int i,j,a,b;

	for(i=0 ; i<pionum ; i++) portdir |= (1<<portoutbit[i]);
 f0003b4:	01800044 	movi	r6,1
 f0003b8:	01000d04 	movi	r4,52

	return 0;
}


int main(void)
 f0003bc:	d9c01104 	addi	r7,sp,68
 f0003c0:	388b883a 	add	r5,r7,r2
	alt_u32 readbitmask = 0;
	alt_u32 portdir = 0;
	alt_u32 pattern, check;
	int i,j,a,b;

	for(i=0 ; i<pionum ; i++) portdir |= (1<<portoutbit[i]);
 f0003c4:	29400017 	ldw	r5,0(r5)
 f0003c8:	10800104 	addi	r2,r2,4
 f0003cc:	314a983a 	sll	r5,r6,r5
 f0003d0:	1946b03a 	or	r3,r3,r5
 f0003d4:	113ff91e 	bne	r2,r4,f0003bc <_gp+0xffff6be0>
	IOWR(GPIO_0_BASE, 0, 0x00000000);	// 全ビット0出力 
 f0003d8:	04440034 	movhi	r17,4096
 f0003dc:	8c408004 	addi	r17,r17,512
 f0003e0:	88000035 	stwio	zero,0(r17)
	IOWR(GPIO_0_BASE, 1, portdir);		// PIO入出力方向設定 
 f0003e4:	00840034 	movhi	r2,4096
 f0003e8:	10808104 	addi	r2,r2,516
 f0003ec:	10c00035 	stwio	r3,0(r2)
 f0003f0:	0005883a 	mov	r2,zero
static int TestPio(void) {
	const int pionum = 13;	// D15とD14は省略 
	const int portoutbit[14] = {0, 27, 2, 25, 4, 23, 6, 21, 9, 19, 11, 17, 13, 15};
	const int portinbit[14] =  {7, 1, 26, 3, 24, 5, 22, 8, 20, 10, 18, 12, 16, 14};

	alt_u32 readbitmask = 0;
 f0003f4:	0027883a 	mov	r19,zero

	for(i=0 ; i<pionum ; i++) portdir |= (1<<portoutbit[i]);
	IOWR(GPIO_0_BASE, 0, 0x00000000);	// 全ビット0出力 
	IOWR(GPIO_0_BASE, 1, portdir);		// PIO入出力方向設定 

	for(i=0 ; i<pionum ; i++) readbitmask |= (1<<portinbit[i]);
 f0003f8:	01400044 	movi	r5,1
 f0003fc:	00c00d04 	movi	r3,52

	return 0;
}


int main(void)
 f000400:	d9800304 	addi	r6,sp,12
 f000404:	3089883a 	add	r4,r6,r2

	for(i=0 ; i<pionum ; i++) portdir |= (1<<portoutbit[i]);
	IOWR(GPIO_0_BASE, 0, 0x00000000);	// 全ビット0出力 
	IOWR(GPIO_0_BASE, 1, portdir);		// PIO入出力方向設定 

	for(i=0 ; i<pionum ; i++) readbitmask |= (1<<portinbit[i]);
 f000408:	21000017 	ldw	r4,0(r4)
 f00040c:	10800104 	addi	r2,r2,4
 f000410:	2908983a 	sll	r4,r5,r4
 f000414:	9926b03a 	or	r19,r19,r4
 f000418:	10fff91e 	bne	r2,r3,f000400 <_gp+0xffff6c24>

	printf("\nPIO test ");
 f00041c:	0103c034 	movhi	r4,3840
 f000420:	21058204 	addi	r4,r4,5640
 f000424:	f0006400 	call	f000640 <printf>
 f000428:	0029883a 	mov	r20,zero

	// '1'シフト 

	for(i=0 ; i<pionum ; i++) {
		pattern = (1<<portoutbit[i]);
 f00042c:	05400044 	movi	r21,1
		IOWR(GPIO_0_BASE, 0, pattern);
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
 f000430:	05800d04 	movi	r22,52

	return 0;
}


int main(void)
 f000434:	d9c01104 	addi	r7,sp,68
 f000438:	3d05883a 	add	r2,r7,r20
	printf("\nPIO test ");

	// '1'シフト 

	for(i=0 ; i<pionum ; i++) {
		pattern = (1<<portoutbit[i]);
 f00043c:	10800017 	ldw	r2,0(r2)
 f000440:	a884983a 	sll	r2,r21,r2
		IOWR(GPIO_0_BASE, 0, pattern);
 f000444:	88800035 	stwio	r2,0(r17)
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
 f000448:	88c00037 	ldwio	r3,0(r17)
		check = IORD(GPIO_0_BASE, 0) & readbitmask;
 f00044c:	88c00037 	ldwio	r3,0(r17)
 f000450:	0021883a 	mov	r16,zero
 f000454:	1cc6703a 	and	r3,r3,r19

	return 0;
}


int main(void)
 f000458:	d9401104 	addi	r5,sp,68
 f00045c:	2c09883a 	add	r4,r5,r16
 f000460:	d9800304 	addi	r6,sp,12
		IOWR(GPIO_0_BASE, 0, pattern);
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
			a = ((pattern & (1<<portoutbit[j])) != 0);
 f000464:	21400017 	ldw	r5,0(r4)

	return 0;
}


int main(void)
 f000468:	3409883a 	add	r4,r6,r16
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
			a = ((pattern & (1<<portoutbit[j])) != 0);
			b = ((check & (1<<portinbit[j])) != 0);
 f00046c:	21800017 	ldw	r6,0(r4)
		IOWR(GPIO_0_BASE, 0, pattern);
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
			a = ((pattern & (1<<portoutbit[j])) != 0);
 f000470:	a94e983a 	sll	r7,r21,r5
			b = ((check & (1<<portinbit[j])) != 0);
 f000474:	a988983a 	sll	r4,r21,r6
		IOWR(GPIO_0_BASE, 0, pattern);
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
			a = ((pattern & (1<<portoutbit[j])) != 0);
 f000478:	388e703a 	and	r7,r7,r2
			b = ((check & (1<<portinbit[j])) != 0);

			if (a != b) {
 f00047c:	380ec03a 	cmpne	r7,r7,zero
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
			a = ((pattern & (1<<portoutbit[j])) != 0);
			b = ((check & (1<<portinbit[j])) != 0);
 f000480:	20c8703a 	and	r4,r4,r3

			if (a != b) {
 f000484:	2008c03a 	cmpne	r4,r4,zero
 f000488:	39000326 	beq	r7,r4,f000498 <main+0x43c>
				printf("\n[!] D%d - D%d path 1-shift error.\n\n",portoutbit[j],portinbit[j]);
 f00048c:	0103c034 	movhi	r4,3840
 f000490:	21058504 	addi	r4,r4,5652
 f000494:	00002206 	br	f000520 <main+0x4c4>
 f000498:	84000104 	addi	r16,r16,4
		pattern = (1<<portoutbit[i]);
		IOWR(GPIO_0_BASE, 0, pattern);
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
 f00049c:	85bfee1e 	bne	r16,r22,f000458 <_gp+0xffff6c7c>
				printf("\n[!] D%d - D%d path 1-shift error.\n\n",portoutbit[j],portinbit[j]);
				return -1;
			}
		}

		printf(".");
 f0004a0:	01000b84 	movi	r4,46
 f0004a4:	a5000104 	addi	r20,r20,4
 f0004a8:	f0006940 	call	f000694 <putchar>

	printf("\nPIO test ");

	// '1'シフト 

	for(i=0 ; i<pionum ; i++) {
 f0004ac:	a43fe11e 	bne	r20,r16,f000434 <_gp+0xffff6c58>
 f0004b0:	0029883a 	mov	r20,zero
	}

	// '0'シフト 

	for(i=0 ; i<pionum ; i++) {
		pattern = ~(1<<portoutbit[i]);
 f0004b4:	05400044 	movi	r21,1
		IOWR(GPIO_0_BASE, 0, pattern);
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
 f0004b8:	05800d04 	movi	r22,52

	return 0;
}


int main(void)
 f0004bc:	d9c01104 	addi	r7,sp,68
 f0004c0:	3d05883a 	add	r2,r7,r20
	}

	// '0'シフト 

	for(i=0 ; i<pionum ; i++) {
		pattern = ~(1<<portoutbit[i]);
 f0004c4:	10800017 	ldw	r2,0(r2)
 f0004c8:	a884983a 	sll	r2,r21,r2
 f0004cc:	0084303a 	nor	r2,zero,r2
		IOWR(GPIO_0_BASE, 0, pattern);
 f0004d0:	88800035 	stwio	r2,0(r17)
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
 f0004d4:	88c00037 	ldwio	r3,0(r17)
		check = IORD(GPIO_0_BASE, 0) & readbitmask;
 f0004d8:	88c00037 	ldwio	r3,0(r17)
 f0004dc:	0021883a 	mov	r16,zero
 f0004e0:	1cc6703a 	and	r3,r3,r19

	return 0;
}


int main(void)
 f0004e4:	d9401104 	addi	r5,sp,68
 f0004e8:	2c09883a 	add	r4,r5,r16
 f0004ec:	d9800304 	addi	r6,sp,12
		IOWR(GPIO_0_BASE, 0, pattern);
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
			a = ((pattern & (1<<portoutbit[j])) == 0);
 f0004f0:	21400017 	ldw	r5,0(r4)

	return 0;
}


int main(void)
 f0004f4:	3409883a 	add	r4,r6,r16
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
			a = ((pattern & (1<<portoutbit[j])) == 0);
			b = ((check & (1<<portinbit[j])) == 0);
 f0004f8:	21800017 	ldw	r6,0(r4)
		IOWR(GPIO_0_BASE, 0, pattern);
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
			a = ((pattern & (1<<portoutbit[j])) == 0);
 f0004fc:	a94e983a 	sll	r7,r21,r5
			b = ((check & (1<<portinbit[j])) == 0);
 f000500:	a988983a 	sll	r4,r21,r6
		IOWR(GPIO_0_BASE, 0, pattern);
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
			a = ((pattern & (1<<portoutbit[j])) == 0);
 f000504:	388e703a 	and	r7,r7,r2
			b = ((check & (1<<portinbit[j])) == 0);

			if (a != b) {
 f000508:	380f003a 	cmpeq	r7,r7,zero
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
			a = ((pattern & (1<<portoutbit[j])) == 0);
			b = ((check & (1<<portinbit[j])) == 0);
 f00050c:	20c8703a 	and	r4,r4,r3

			if (a != b) {
 f000510:	2009003a 	cmpeq	r4,r4,zero
 f000514:	39000426 	beq	r7,r4,f000528 <main+0x4cc>
				printf("\n[!] D%d - D%d path 0-shift error.\n\n",portoutbit[j],portinbit[j]);
 f000518:	0103c034 	movhi	r4,3840
 f00051c:	21058f04 	addi	r4,r4,5692
 f000520:	f0006400 	call	f000640 <printf>
 f000524:	00000c06 	br	f000558 <main+0x4fc>
 f000528:	84000104 	addi	r16,r16,4
		pattern = ~(1<<portoutbit[i]);
		IOWR(GPIO_0_BASE, 0, pattern);
		IORD(GPIO_0_BASE, 0);	// ダミーリード 
		check = IORD(GPIO_0_BASE, 0) & readbitmask;

		for(j=0 ; j<pionum ; j++) {
 f00052c:	85bfed1e 	bne	r16,r22,f0004e4 <_gp+0xffff6d08>
				printf("\n[!] D%d - D%d path 0-shift error.\n\n",portoutbit[j],portinbit[j]);
				return -2;
			}
		}

		printf(".");
 f000530:	01000b84 	movi	r4,46
 f000534:	a5000104 	addi	r20,r20,4
 f000538:	f0006940 	call	f000694 <putchar>
		printf(".");
	}

	// '0'シフト 

	for(i=0 ; i<pionum ; i++) {
 f00053c:	a43fdf1e 	bne	r20,r16,f0004bc <_gp+0xffff6ce0>
		}

		printf(".");
	}

	printf(" passed\n");
 f000540:	0103c034 	movhi	r4,3840
 f000544:	21056504 	addi	r4,r4,5524
 f000548:	f0007300 	call	f000730 <puts>
	printf("PIO at Okay\n");
 f00054c:	0103c034 	movhi	r4,3840
 f000550:	21059904 	addi	r4,r4,5732
 f000554:	f0007300 	call	f000730 <puts>
	writebuf[0] = 0xab;		// OPCODE 
	writebuf[1] = 0xff;		// dummy byte 
	writebuf[2] = 0xff;		// dummy byte 
	writebuf[3] = 0xff;		// dummy byte 

	alt_avalon_spi_command(
 f000558:	d9c00304 	addi	r7,sp,12

static int TestEpcs(void) {
	alt_u8 writebuf[8];
	alt_u8 readbuf[8];

	writebuf[0] = 0xab;		// OPCODE 
 f00055c:	00bfeac4 	movi	r2,-85
	writebuf[1] = 0xff;		// dummy byte 
	writebuf[2] = 0xff;		// dummy byte 
	writebuf[3] = 0xff;		// dummy byte 

	alt_avalon_spi_command(
 f000560:	04000044 	movi	r16,1

static int TestEpcs(void) {
	alt_u8 writebuf[8];
	alt_u8 readbuf[8];

	writebuf[0] = 0xab;		// OPCODE 
 f000564:	d8801105 	stb	r2,68(sp)
	writebuf[1] = 0xff;		// dummy byte 
	writebuf[2] = 0xff;		// dummy byte 
	writebuf[3] = 0xff;		// dummy byte 

	alt_avalon_spi_command(
 f000568:	d9c00115 	stw	r7,4(sp)
static int TestEpcs(void) {
	alt_u8 writebuf[8];
	alt_u8 readbuf[8];

	writebuf[0] = 0xab;		// OPCODE 
	writebuf[1] = 0xff;		// dummy byte 
 f00056c:	00bfffc4 	movi	r2,-1
	writebuf[2] = 0xff;		// dummy byte 
	writebuf[3] = 0xff;		// dummy byte 

	alt_avalon_spi_command(
 f000570:	01800104 	movi	r6,4
 f000574:	d9c01104 	addi	r7,sp,68
 f000578:	dc000015 	stw	r16,0(sp)
 f00057c:	d8000215 	stw	zero,8(sp)
 f000580:	01040034 	movhi	r4,4096
 f000584:	21010004 	addi	r4,r4,1024
 f000588:	000b883a 	mov	r5,zero
static int TestEpcs(void) {
	alt_u8 writebuf[8];
	alt_u8 readbuf[8];

	writebuf[0] = 0xab;		// OPCODE 
	writebuf[1] = 0xff;		// dummy byte 
 f00058c:	d8801145 	stb	r2,69(sp)
	writebuf[2] = 0xff;		// dummy byte 
 f000590:	d8801185 	stb	r2,70(sp)
	writebuf[3] = 0xff;		// dummy byte 
 f000594:	d88011c5 	stb	r2,71(sp)

	alt_avalon_spi_command(
 f000598:	f0013ec0 	call	f0013ec <alt_avalon_spi_command>
			EPCS_SPI_BASE, 0,
			4, writebuf,
			1, readbuf,
			0);

	printf("EPCS Silicon ID = 0x%02X\n", readbuf[0]);
 f00059c:	d9400303 	ldbu	r5,12(sp)
 f0005a0:	0103c034 	movhi	r4,3840
 f0005a4:	21059c04 	addi	r4,r4,5744
 f0005a8:	f0006400 	call	f000640 <printf>

	TestPio();

	TestEpcs();

	IOWR(LED_BASE, 0, 1);	// LED点灯 
 f0005ac:	94000035 	stwio	r16,0(r18)
 f0005b0:	003fff06 	br	f0005b0 <_gp+0xffff6dd4>

0f0005b4 <__mulsi3>:
 f0005b4:	0005883a 	mov	r2,zero
 f0005b8:	20000726 	beq	r4,zero,f0005d8 <__mulsi3+0x24>
 f0005bc:	20c0004c 	andi	r3,r4,1
 f0005c0:	2008d07a 	srli	r4,r4,1
 f0005c4:	18000126 	beq	r3,zero,f0005cc <__mulsi3+0x18>
 f0005c8:	1145883a 	add	r2,r2,r5
 f0005cc:	294b883a 	add	r5,r5,r5
 f0005d0:	203ffa1e 	bne	r4,zero,f0005bc <_gp+0xffff6de0>
 f0005d4:	f800283a 	ret
 f0005d8:	f800283a 	ret

0f0005dc <memcpy>:
 f0005dc:	2005883a 	mov	r2,r4
 f0005e0:	30000726 	beq	r6,zero,f000600 <memcpy+0x24>
 f0005e4:	218d883a 	add	r6,r4,r6
 f0005e8:	2007883a 	mov	r3,r4
 f0005ec:	29c00003 	ldbu	r7,0(r5)
 f0005f0:	18c00044 	addi	r3,r3,1
 f0005f4:	29400044 	addi	r5,r5,1
 f0005f8:	19ffffc5 	stb	r7,-1(r3)
 f0005fc:	19bffb1e 	bne	r3,r6,f0005ec <_gp+0xffff6e10>
 f000600:	f800283a 	ret

0f000604 <_printf_r>:
 f000604:	defffd04 	addi	sp,sp,-12
 f000608:	dfc00015 	stw	ra,0(sp)
 f00060c:	d9800115 	stw	r6,4(sp)
 f000610:	d9c00215 	stw	r7,8(sp)
 f000614:	20800217 	ldw	r2,8(r4)
 f000618:	00c3c034 	movhi	r3,3840
 f00061c:	18c3b104 	addi	r3,r3,3780
 f000620:	280d883a 	mov	r6,r5
 f000624:	10c00115 	stw	r3,4(r2)
 f000628:	100b883a 	mov	r5,r2
 f00062c:	d9c00104 	addi	r7,sp,4
 f000630:	f00076c0 	call	f00076c <___vfprintf_internal_r>
 f000634:	dfc00017 	ldw	ra,0(sp)
 f000638:	dec00304 	addi	sp,sp,12
 f00063c:	f800283a 	ret

0f000640 <printf>:
 f000640:	defffc04 	addi	sp,sp,-16
 f000644:	dfc00015 	stw	ra,0(sp)
 f000648:	d9400115 	stw	r5,4(sp)
 f00064c:	d9800215 	stw	r6,8(sp)
 f000650:	d9c00315 	stw	r7,12(sp)
 f000654:	0083c034 	movhi	r2,3840
 f000658:	1085f804 	addi	r2,r2,6112
 f00065c:	10800017 	ldw	r2,0(r2)
 f000660:	00c3c034 	movhi	r3,3840
 f000664:	18c3b104 	addi	r3,r3,3780
 f000668:	200b883a 	mov	r5,r4
 f00066c:	10800217 	ldw	r2,8(r2)
 f000670:	d9800104 	addi	r6,sp,4
 f000674:	10c00115 	stw	r3,4(r2)
 f000678:	1009883a 	mov	r4,r2
 f00067c:	f000ea00 	call	f000ea0 <__vfprintf_internal>
 f000680:	dfc00017 	ldw	ra,0(sp)
 f000684:	dec00404 	addi	sp,sp,16
 f000688:	f800283a 	ret

0f00068c <_putchar_r>:
 f00068c:	21800217 	ldw	r6,8(r4)
 f000690:	f0010001 	jmpi	f001000 <_putc_r>

0f000694 <putchar>:
 f000694:	0083c034 	movhi	r2,3840
 f000698:	1085f804 	addi	r2,r2,6112
 f00069c:	10800017 	ldw	r2,0(r2)
 f0006a0:	200b883a 	mov	r5,r4
 f0006a4:	11800217 	ldw	r6,8(r2)
 f0006a8:	1009883a 	mov	r4,r2
 f0006ac:	f0010001 	jmpi	f001000 <_putc_r>

0f0006b0 <_puts_r>:
 f0006b0:	defffd04 	addi	sp,sp,-12
 f0006b4:	dc000015 	stw	r16,0(sp)
 f0006b8:	2021883a 	mov	r16,r4
 f0006bc:	2809883a 	mov	r4,r5
 f0006c0:	dfc00215 	stw	ra,8(sp)
 f0006c4:	dc400115 	stw	r17,4(sp)
 f0006c8:	2823883a 	mov	r17,r5
 f0006cc:	f0007440 	call	f000744 <strlen>
 f0006d0:	81400217 	ldw	r5,8(r16)
 f0006d4:	00c3c034 	movhi	r3,3840
 f0006d8:	18c3b104 	addi	r3,r3,3780
 f0006dc:	880d883a 	mov	r6,r17
 f0006e0:	8009883a 	mov	r4,r16
 f0006e4:	28c00115 	stw	r3,4(r5)
 f0006e8:	100f883a 	mov	r7,r2
 f0006ec:	183ee83a 	callr	r3
 f0006f0:	047fffc4 	movi	r17,-1
 f0006f4:	14400926 	beq	r2,r17,f00071c <_puts_r+0x6c>
 f0006f8:	81400217 	ldw	r5,8(r16)
 f0006fc:	8009883a 	mov	r4,r16
 f000700:	0183c034 	movhi	r6,3840
 f000704:	3185a204 	addi	r6,r6,5768
 f000708:	28800117 	ldw	r2,4(r5)
 f00070c:	01c00044 	movi	r7,1
 f000710:	103ee83a 	callr	r2
 f000714:	14400126 	beq	r2,r17,f00071c <_puts_r+0x6c>
 f000718:	0005883a 	mov	r2,zero
 f00071c:	dfc00217 	ldw	ra,8(sp)
 f000720:	dc400117 	ldw	r17,4(sp)
 f000724:	dc000017 	ldw	r16,0(sp)
 f000728:	dec00304 	addi	sp,sp,12
 f00072c:	f800283a 	ret

0f000730 <puts>:
 f000730:	0083c034 	movhi	r2,3840
 f000734:	1085f804 	addi	r2,r2,6112
 f000738:	200b883a 	mov	r5,r4
 f00073c:	11000017 	ldw	r4,0(r2)
 f000740:	f0006b01 	jmpi	f0006b0 <_puts_r>

0f000744 <strlen>:
 f000744:	20800007 	ldb	r2,0(r4)
 f000748:	10000626 	beq	r2,zero,f000764 <strlen+0x20>
 f00074c:	2005883a 	mov	r2,r4
 f000750:	10800044 	addi	r2,r2,1
 f000754:	10c00007 	ldb	r3,0(r2)
 f000758:	183ffd1e 	bne	r3,zero,f000750 <_gp+0xffff6f74>
 f00075c:	1105c83a 	sub	r2,r2,r4
 f000760:	f800283a 	ret
 f000764:	0005883a 	mov	r2,zero
 f000768:	f800283a 	ret

0f00076c <___vfprintf_internal_r>:
 f00076c:	deffe004 	addi	sp,sp,-128
 f000770:	d8c00804 	addi	r3,sp,32
 f000774:	ddc01d15 	stw	r23,116(sp)
 f000778:	dd401b15 	stw	r21,108(sp)
 f00077c:	dd001a15 	stw	r20,104(sp)
 f000780:	dcc01915 	stw	r19,100(sp)
 f000784:	dc801815 	stw	r18,96(sp)
 f000788:	dc001615 	stw	r16,88(sp)
 f00078c:	dfc01f15 	stw	ra,124(sp)
 f000790:	df001e15 	stw	fp,120(sp)
 f000794:	dd801c15 	stw	r22,112(sp)
 f000798:	dc401715 	stw	r17,92(sp)
 f00079c:	d9000f15 	stw	r4,60(sp)
 f0007a0:	d9c00e15 	stw	r7,56(sp)
 f0007a4:	3021883a 	mov	r16,r6
 f0007a8:	0025883a 	mov	r18,zero
 f0007ac:	d8001415 	stw	zero,80(sp)
 f0007b0:	d8000d15 	stw	zero,52(sp)
 f0007b4:	0029883a 	mov	r20,zero
 f0007b8:	d8000b15 	stw	zero,44(sp)
 f0007bc:	d8000c15 	stw	zero,48(sp)
 f0007c0:	d8001315 	stw	zero,76(sp)
 f0007c4:	d8001015 	stw	zero,64(sp)
 f0007c8:	002b883a 	mov	r21,zero
 f0007cc:	04c00044 	movi	r19,1
 f0007d0:	d8c00a15 	stw	r3,40(sp)
 f0007d4:	282f883a 	mov	r23,r5
 f0007d8:	80c00003 	ldbu	r3,0(r16)
 f0007dc:	84000044 	addi	r16,r16,1
 f0007e0:	18803fcc 	andi	r2,r3,255
 f0007e4:	1080201c 	xori	r2,r2,128
 f0007e8:	10bfe004 	addi	r2,r2,-128
 f0007ec:	10001426 	beq	r2,zero,f000840 <___vfprintf_internal_r+0xd4>
 f0007f0:	acc03026 	beq	r21,r19,f0008b4 <___vfprintf_internal_r+0x148>
 f0007f4:	9d401f16 	blt	r19,r21,f000874 <___vfprintf_internal_r+0x108>
 f0007f8:	a83ff71e 	bne	r21,zero,f0007d8 <_gp+0xffff6ffc>
 f0007fc:	01000944 	movi	r4,37
 f000800:	1100d926 	beq	r2,r4,f000b68 <___vfprintf_internal_r+0x3fc>
 f000804:	b8800117 	ldw	r2,4(r23)
 f000808:	d9000f17 	ldw	r4,60(sp)
 f00080c:	d8c00905 	stb	r3,36(sp)
 f000810:	b80b883a 	mov	r5,r23
 f000814:	d9800904 	addi	r6,sp,36
 f000818:	01c00044 	movi	r7,1
 f00081c:	103ee83a 	callr	r2
 f000820:	1000a31e 	bne	r2,zero,f000ab0 <___vfprintf_internal_r+0x344>
 f000824:	80c00003 	ldbu	r3,0(r16)
 f000828:	94800044 	addi	r18,r18,1
 f00082c:	84000044 	addi	r16,r16,1
 f000830:	18803fcc 	andi	r2,r3,255
 f000834:	1080201c 	xori	r2,r2,128
 f000838:	10bfe004 	addi	r2,r2,-128
 f00083c:	103fec1e 	bne	r2,zero,f0007f0 <_gp+0xffff7014>
 f000840:	9005883a 	mov	r2,r18
 f000844:	dfc01f17 	ldw	ra,124(sp)
 f000848:	df001e17 	ldw	fp,120(sp)
 f00084c:	ddc01d17 	ldw	r23,116(sp)
 f000850:	dd801c17 	ldw	r22,112(sp)
 f000854:	dd401b17 	ldw	r21,108(sp)
 f000858:	dd001a17 	ldw	r20,104(sp)
 f00085c:	dcc01917 	ldw	r19,100(sp)
 f000860:	dc801817 	ldw	r18,96(sp)
 f000864:	dc401717 	ldw	r17,92(sp)
 f000868:	dc001617 	ldw	r16,88(sp)
 f00086c:	dec02004 	addi	sp,sp,128
 f000870:	f800283a 	ret
 f000874:	01000084 	movi	r4,2
 f000878:	a9001226 	beq	r21,r4,f0008c4 <___vfprintf_internal_r+0x158>
 f00087c:	010000c4 	movi	r4,3
 f000880:	a93fd51e 	bne	r21,r4,f0007d8 <_gp+0xffff6ffc>
 f000884:	1c7ff404 	addi	r17,r3,-48
 f000888:	8c403fcc 	andi	r17,r17,255
 f00088c:	01000244 	movi	r4,9
 f000890:	24401b36 	bltu	r4,r17,f000900 <___vfprintf_internal_r+0x194>
 f000894:	d9000b17 	ldw	r4,44(sp)
 f000898:	00bfffc4 	movi	r2,-1
 f00089c:	2080ea26 	beq	r4,r2,f000c48 <___vfprintf_internal_r+0x4dc>
 f0008a0:	01400284 	movi	r5,10
 f0008a4:	f0005b40 	call	f0005b4 <__mulsi3>
 f0008a8:	88a3883a 	add	r17,r17,r2
 f0008ac:	dc400b15 	stw	r17,44(sp)
 f0008b0:	003fc906 	br	f0007d8 <_gp+0xffff6ffc>
 f0008b4:	01000c04 	movi	r4,48
 f0008b8:	1100de26 	beq	r2,r4,f000c34 <___vfprintf_internal_r+0x4c8>
 f0008bc:	01000944 	movi	r4,37
 f0008c0:	1100fd26 	beq	r2,r4,f000cb8 <___vfprintf_internal_r+0x54c>
 f0008c4:	1c7ff404 	addi	r17,r3,-48
 f0008c8:	8c403fcc 	andi	r17,r17,255
 f0008cc:	01000244 	movi	r4,9
 f0008d0:	24400936 	bltu	r4,r17,f0008f8 <___vfprintf_internal_r+0x18c>
 f0008d4:	d9000c17 	ldw	r4,48(sp)
 f0008d8:	00bfffc4 	movi	r2,-1
 f0008dc:	2080d826 	beq	r4,r2,f000c40 <___vfprintf_internal_r+0x4d4>
 f0008e0:	01400284 	movi	r5,10
 f0008e4:	f0005b40 	call	f0005b4 <__mulsi3>
 f0008e8:	88a3883a 	add	r17,r17,r2
 f0008ec:	dc400c15 	stw	r17,48(sp)
 f0008f0:	05400084 	movi	r21,2
 f0008f4:	003fb806 	br	f0007d8 <_gp+0xffff6ffc>
 f0008f8:	01000b84 	movi	r4,46
 f0008fc:	1100a726 	beq	r2,r4,f000b9c <___vfprintf_internal_r+0x430>
 f000900:	01401b04 	movi	r5,108
 f000904:	1140a326 	beq	r2,r5,f000b94 <___vfprintf_internal_r+0x428>
 f000908:	d9000b17 	ldw	r4,44(sp)
 f00090c:	00bfffc4 	movi	r2,-1
 f000910:	2080e626 	beq	r4,r2,f000cac <___vfprintf_internal_r+0x540>
 f000914:	d8001015 	stw	zero,64(sp)
 f000918:	18ffea04 	addi	r3,r3,-88
 f00091c:	18c03fcc 	andi	r3,r3,255
 f000920:	00800804 	movi	r2,32
 f000924:	10c0022e 	bgeu	r2,r3,f000930 <___vfprintf_internal_r+0x1c4>
 f000928:	002b883a 	mov	r21,zero
 f00092c:	003faa06 	br	f0007d8 <_gp+0xffff6ffc>
 f000930:	18c7883a 	add	r3,r3,r3
 f000934:	18c7883a 	add	r3,r3,r3
 f000938:	0143c034 	movhi	r5,3840
 f00093c:	29425304 	addi	r5,r5,2380
 f000940:	1947883a 	add	r3,r3,r5
 f000944:	18800017 	ldw	r2,0(r3)
 f000948:	1000683a 	jmp	r2
 f00094c:	0f000ce4 	muli	fp,at,51
 f000950:	0f000928 	cmpgeui	fp,at,36
 f000954:	0f000928 	cmpgeui	fp,at,36
 f000958:	0f000928 	cmpgeui	fp,at,36
 f00095c:	0f000928 	cmpgeui	fp,at,36
 f000960:	0f000928 	cmpgeui	fp,at,36
 f000964:	0f000928 	cmpgeui	fp,at,36
 f000968:	0f000928 	cmpgeui	fp,at,36
 f00096c:	0f000928 	cmpgeui	fp,at,36
 f000970:	0f000928 	cmpgeui	fp,at,36
 f000974:	0f000928 	cmpgeui	fp,at,36
 f000978:	0f000cf4 	orhi	fp,at,51
 f00097c:	0f0009d0 	cmplti	fp,at,39
 f000980:	0f000928 	cmpgeui	fp,at,36
 f000984:	0f000928 	cmpgeui	fp,at,36
 f000988:	0f000928 	cmpgeui	fp,at,36
 f00098c:	0f000928 	cmpgeui	fp,at,36
 f000990:	0f0009d0 	cmplti	fp,at,39
 f000994:	0f000928 	cmpgeui	fp,at,36
 f000998:	0f000928 	cmpgeui	fp,at,36
 f00099c:	0f000928 	cmpgeui	fp,at,36
 f0009a0:	0f000928 	cmpgeui	fp,at,36
 f0009a4:	0f000928 	cmpgeui	fp,at,36
 f0009a8:	0f000ab8 	rdprs	fp,at,42
 f0009ac:	0f000928 	cmpgeui	fp,at,36
 f0009b0:	0f000928 	cmpgeui	fp,at,36
 f0009b4:	0f000928 	cmpgeui	fp,at,36
 f0009b8:	0f000d40 	call	f000d4 <__alt_mem_sdram+0xf000d4>
 f0009bc:	0f000928 	cmpgeui	fp,at,36
 f0009c0:	0f000abc 	xorhi	fp,at,42
 f0009c4:	0f000928 	cmpgeui	fp,at,36
 f0009c8:	0f000928 	cmpgeui	fp,at,36
 f0009cc:	0f000cec 	andhi	fp,at,51
 f0009d0:	d8c00d17 	ldw	r3,52(sp)
 f0009d4:	18003926 	beq	r3,zero,f000abc <___vfprintf_internal_r+0x350>
 f0009d8:	d9000e17 	ldw	r4,56(sp)
 f0009dc:	00c00044 	movi	r3,1
 f0009e0:	25400017 	ldw	r21,0(r4)
 f0009e4:	21000104 	addi	r4,r4,4
 f0009e8:	d9000e15 	stw	r4,56(sp)
 f0009ec:	d8c00d15 	stw	r3,52(sp)
 f0009f0:	a8012116 	blt	r21,zero,f000e78 <___vfprintf_internal_r+0x70c>
 f0009f4:	d8001215 	stw	zero,72(sp)
 f0009f8:	d823883a 	mov	r17,sp
 f0009fc:	a800371e 	bne	r21,zero,f000adc <___vfprintf_internal_r+0x370>
 f000a00:	d9400b17 	ldw	r5,44(sp)
 f000a04:	d809883a 	mov	r4,sp
 f000a08:	01400b0e 	bge	zero,r5,f000a38 <___vfprintf_internal_r+0x2cc>
 f000a0c:	d8800b17 	ldw	r2,44(sp)
 f000a10:	d823883a 	mov	r17,sp
 f000a14:	00c00c04 	movi	r3,48
 f000a18:	00000206 	br	f000a24 <___vfprintf_internal_r+0x2b8>
 f000a1c:	d9400a17 	ldw	r5,40(sp)
 f000a20:	89400426 	beq	r17,r5,f000a34 <___vfprintf_internal_r+0x2c8>
 f000a24:	88c00005 	stb	r3,0(r17)
 f000a28:	10bfffc4 	addi	r2,r2,-1
 f000a2c:	8c400044 	addi	r17,r17,1
 f000a30:	103ffa1e 	bne	r2,zero,f000a1c <_gp+0xffff7240>
 f000a34:	892bc83a 	sub	r21,r17,r4
 f000a38:	d8c01217 	ldw	r3,72(sp)
 f000a3c:	d9000c17 	ldw	r4,48(sp)
 f000a40:	a8c5883a 	add	r2,r21,r3
 f000a44:	d8c01017 	ldw	r3,64(sp)
 f000a48:	2085c83a 	sub	r2,r4,r2
 f000a4c:	d8801115 	stw	r2,68(sp)
 f000a50:	18007f26 	beq	r3,zero,f000c50 <___vfprintf_internal_r+0x4e4>
 f000a54:	d8c01217 	ldw	r3,72(sp)
 f000a58:	1800fa1e 	bne	r3,zero,f000e44 <___vfprintf_internal_r+0x6d8>
 f000a5c:	d8c01117 	ldw	r3,68(sp)
 f000a60:	00c0620e 	bge	zero,r3,f000bec <___vfprintf_internal_r+0x480>
 f000a64:	00800c04 	movi	r2,48
 f000a68:	d88008c5 	stb	r2,35(sp)
 f000a6c:	b805883a 	mov	r2,r23
 f000a70:	dc001215 	stw	r16,72(sp)
 f000a74:	882f883a 	mov	r23,r17
 f000a78:	1f3fffc4 	addi	fp,r3,-1
 f000a7c:	05bfffc4 	movi	r22,-1
 f000a80:	dc000f17 	ldw	r16,60(sp)
 f000a84:	1023883a 	mov	r17,r2
 f000a88:	00000206 	br	f000a94 <___vfprintf_internal_r+0x328>
 f000a8c:	e73fffc4 	addi	fp,fp,-1
 f000a90:	e580fc26 	beq	fp,r22,f000e84 <___vfprintf_internal_r+0x718>
 f000a94:	88800117 	ldw	r2,4(r17)
 f000a98:	8009883a 	mov	r4,r16
 f000a9c:	880b883a 	mov	r5,r17
 f000aa0:	d98008c4 	addi	r6,sp,35
 f000aa4:	01c00044 	movi	r7,1
 f000aa8:	103ee83a 	callr	r2
 f000aac:	103ff726 	beq	r2,zero,f000a8c <_gp+0xffff72b0>
 f000ab0:	04bfffc4 	movi	r18,-1
 f000ab4:	003f6206 	br	f000840 <_gp+0xffff7064>
 f000ab8:	05000204 	movi	r20,8
 f000abc:	d9400e17 	ldw	r5,56(sp)
 f000ac0:	2d400017 	ldw	r21,0(r5)
 f000ac4:	29400104 	addi	r5,r5,4
 f000ac8:	d9400e15 	stw	r5,56(sp)
 f000acc:	d8000d15 	stw	zero,52(sp)
 f000ad0:	d8001215 	stw	zero,72(sp)
 f000ad4:	d823883a 	mov	r17,sp
 f000ad8:	a83fc926 	beq	r21,zero,f000a00 <_gp+0xffff7224>
 f000adc:	05800244 	movi	r22,9
 f000ae0:	dc001115 	stw	r16,68(sp)
 f000ae4:	df001417 	ldw	fp,80(sp)
 f000ae8:	00000506 	br	f000b00 <___vfprintf_internal_r+0x394>
 f000aec:	15400c04 	addi	r21,r2,48
 f000af0:	8d400005 	stb	r21,0(r17)
 f000af4:	802b883a 	mov	r21,r16
 f000af8:	8c400044 	addi	r17,r17,1
 f000afc:	80000f26 	beq	r16,zero,f000b3c <___vfprintf_internal_r+0x3d0>
 f000b00:	a809883a 	mov	r4,r21
 f000b04:	a00b883a 	mov	r5,r20
 f000b08:	f0011ec0 	call	f0011ec <__udivsi3>
 f000b0c:	a009883a 	mov	r4,r20
 f000b10:	100b883a 	mov	r5,r2
 f000b14:	1021883a 	mov	r16,r2
 f000b18:	f0005b40 	call	f0005b4 <__mulsi3>
 f000b1c:	a885c83a 	sub	r2,r21,r2
 f000b20:	b0bff20e 	bge	r22,r2,f000aec <_gp+0xffff7310>
 f000b24:	e0000e26 	beq	fp,zero,f000b60 <___vfprintf_internal_r+0x3f4>
 f000b28:	15400dc4 	addi	r21,r2,55
 f000b2c:	8d400005 	stb	r21,0(r17)
 f000b30:	802b883a 	mov	r21,r16
 f000b34:	8c400044 	addi	r17,r17,1
 f000b38:	803ff11e 	bne	r16,zero,f000b00 <_gp+0xffff7324>
 f000b3c:	d9000b17 	ldw	r4,44(sp)
 f000b40:	8eebc83a 	sub	r21,r17,sp
 f000b44:	dc001117 	ldw	r16,68(sp)
 f000b48:	2545c83a 	sub	r2,r4,r21
 f000b4c:	d809883a 	mov	r4,sp
 f000b50:	00bfb90e 	bge	zero,r2,f000a38 <_gp+0xffff725c>
 f000b54:	d8c00a17 	ldw	r3,40(sp)
 f000b58:	88ffae36 	bltu	r17,r3,f000a14 <_gp+0xffff7238>
 f000b5c:	003fb606 	br	f000a38 <_gp+0xffff725c>
 f000b60:	154015c4 	addi	r21,r2,87
 f000b64:	003fe206 	br	f000af0 <_gp+0xffff7314>
 f000b68:	00c00044 	movi	r3,1
 f000b6c:	013fffc4 	movi	r4,-1
 f000b70:	d8c00d15 	stw	r3,52(sp)
 f000b74:	d9000b15 	stw	r4,44(sp)
 f000b78:	d8001415 	stw	zero,80(sp)
 f000b7c:	05000284 	movi	r20,10
 f000b80:	d9000c15 	stw	r4,48(sp)
 f000b84:	d8001315 	stw	zero,76(sp)
 f000b88:	d8001015 	stw	zero,64(sp)
 f000b8c:	182b883a 	mov	r21,r3
 f000b90:	003f1106 	br	f0007d8 <_gp+0xffff6ffc>
 f000b94:	00c00044 	movi	r3,1
 f000b98:	d8c01315 	stw	r3,76(sp)
 f000b9c:	054000c4 	movi	r21,3
 f000ba0:	003f0d06 	br	f0007d8 <_gp+0xffff6ffc>
 f000ba4:	d8c01117 	ldw	r3,68(sp)
 f000ba8:	dc001517 	ldw	r16,84(sp)
 f000bac:	8805883a 	mov	r2,r17
 f000bb0:	90e5883a 	add	r18,r18,r3
 f000bb4:	b823883a 	mov	r17,r23
 f000bb8:	102f883a 	mov	r23,r2
 f000bbc:	d8c01217 	ldw	r3,72(sp)
 f000bc0:	18000a26 	beq	r3,zero,f000bec <___vfprintf_internal_r+0x480>
 f000bc4:	b8800117 	ldw	r2,4(r23)
 f000bc8:	d9000f17 	ldw	r4,60(sp)
 f000bcc:	00c00b44 	movi	r3,45
 f000bd0:	d8c00905 	stb	r3,36(sp)
 f000bd4:	b80b883a 	mov	r5,r23
 f000bd8:	d9800904 	addi	r6,sp,36
 f000bdc:	01c00044 	movi	r7,1
 f000be0:	103ee83a 	callr	r2
 f000be4:	103fb21e 	bne	r2,zero,f000ab0 <_gp+0xffff72d4>
 f000be8:	94800044 	addi	r18,r18,1
 f000bec:	8d6dc83a 	sub	r22,r17,r21
 f000bf0:	057f4d0e 	bge	zero,r21,f000928 <_gp+0xffff714c>
 f000bf4:	dd400f17 	ldw	r21,60(sp)
 f000bf8:	00000206 	br	f000c04 <___vfprintf_internal_r+0x498>
 f000bfc:	94800044 	addi	r18,r18,1
 f000c00:	8dbf4926 	beq	r17,r22,f000928 <_gp+0xffff714c>
 f000c04:	8c7fffc4 	addi	r17,r17,-1
 f000c08:	88c00003 	ldbu	r3,0(r17)
 f000c0c:	b8800117 	ldw	r2,4(r23)
 f000c10:	a809883a 	mov	r4,r21
 f000c14:	d8c00905 	stb	r3,36(sp)
 f000c18:	b80b883a 	mov	r5,r23
 f000c1c:	d9800904 	addi	r6,sp,36
 f000c20:	01c00044 	movi	r7,1
 f000c24:	103ee83a 	callr	r2
 f000c28:	103ff426 	beq	r2,zero,f000bfc <_gp+0xffff7420>
 f000c2c:	04bfffc4 	movi	r18,-1
 f000c30:	003f0306 	br	f000840 <_gp+0xffff7064>
 f000c34:	dd401015 	stw	r21,64(sp)
 f000c38:	05400084 	movi	r21,2
 f000c3c:	003ee606 	br	f0007d8 <_gp+0xffff6ffc>
 f000c40:	0005883a 	mov	r2,zero
 f000c44:	003f2806 	br	f0008e8 <_gp+0xffff710c>
 f000c48:	0005883a 	mov	r2,zero
 f000c4c:	003f1606 	br	f0008a8 <_gp+0xffff70cc>
 f000c50:	d8c01117 	ldw	r3,68(sp)
 f000c54:	00ffd90e 	bge	zero,r3,f000bbc <_gp+0xffff73e0>
 f000c58:	00800804 	movi	r2,32
 f000c5c:	d8800885 	stb	r2,34(sp)
 f000c60:	b805883a 	mov	r2,r23
 f000c64:	dc001515 	stw	r16,84(sp)
 f000c68:	882f883a 	mov	r23,r17
 f000c6c:	1f3fffc4 	addi	fp,r3,-1
 f000c70:	05bfffc4 	movi	r22,-1
 f000c74:	dc000f17 	ldw	r16,60(sp)
 f000c78:	1023883a 	mov	r17,r2
 f000c7c:	00000206 	br	f000c88 <___vfprintf_internal_r+0x51c>
 f000c80:	e73fffc4 	addi	fp,fp,-1
 f000c84:	e5bfc726 	beq	fp,r22,f000ba4 <_gp+0xffff73c8>
 f000c88:	88800117 	ldw	r2,4(r17)
 f000c8c:	8009883a 	mov	r4,r16
 f000c90:	880b883a 	mov	r5,r17
 f000c94:	d9800884 	addi	r6,sp,34
 f000c98:	01c00044 	movi	r7,1
 f000c9c:	103ee83a 	callr	r2
 f000ca0:	103ff726 	beq	r2,zero,f000c80 <_gp+0xffff74a4>
 f000ca4:	04bfffc4 	movi	r18,-1
 f000ca8:	003ee506 	br	f000840 <_gp+0xffff7064>
 f000cac:	01000044 	movi	r4,1
 f000cb0:	d9000b15 	stw	r4,44(sp)
 f000cb4:	003f1806 	br	f000918 <_gp+0xffff713c>
 f000cb8:	b8c00117 	ldw	r3,4(r23)
 f000cbc:	d9000f17 	ldw	r4,60(sp)
 f000cc0:	d8800905 	stb	r2,36(sp)
 f000cc4:	b80b883a 	mov	r5,r23
 f000cc8:	d9800904 	addi	r6,sp,36
 f000ccc:	a80f883a 	mov	r7,r21
 f000cd0:	183ee83a 	callr	r3
 f000cd4:	103f761e 	bne	r2,zero,f000ab0 <_gp+0xffff72d4>
 f000cd8:	94800044 	addi	r18,r18,1
 f000cdc:	002b883a 	mov	r21,zero
 f000ce0:	003ebd06 	br	f0007d8 <_gp+0xffff6ffc>
 f000ce4:	00c00044 	movi	r3,1
 f000ce8:	d8c01415 	stw	r3,80(sp)
 f000cec:	05000404 	movi	r20,16
 f000cf0:	003f7206 	br	f000abc <_gp+0xffff72e0>
 f000cf4:	d9000c17 	ldw	r4,48(sp)
 f000cf8:	9900420e 	bge	r19,r4,f000e04 <___vfprintf_internal_r+0x698>
 f000cfc:	df000f17 	ldw	fp,60(sp)
 f000d00:	25bfffc4 	addi	r22,r4,-1
 f000d04:	00800804 	movi	r2,32
 f000d08:	d8800845 	stb	r2,33(sp)
 f000d0c:	b023883a 	mov	r17,r22
 f000d10:	057fffc4 	movi	r21,-1
 f000d14:	8c7fffc4 	addi	r17,r17,-1
 f000d18:	8d403926 	beq	r17,r21,f000e00 <___vfprintf_internal_r+0x694>
 f000d1c:	b8800117 	ldw	r2,4(r23)
 f000d20:	e009883a 	mov	r4,fp
 f000d24:	b80b883a 	mov	r5,r23
 f000d28:	d9800844 	addi	r6,sp,33
 f000d2c:	01c00044 	movi	r7,1
 f000d30:	103ee83a 	callr	r2
 f000d34:	103ff726 	beq	r2,zero,f000d14 <_gp+0xffff7538>
 f000d38:	04bfffc4 	movi	r18,-1
 f000d3c:	003ec006 	br	f000840 <_gp+0xffff7064>
 f000d40:	d9000e17 	ldw	r4,56(sp)
 f000d44:	d8c00e17 	ldw	r3,56(sp)
 f000d48:	21000017 	ldw	r4,0(r4)
 f000d4c:	18c00104 	addi	r3,r3,4
 f000d50:	d8c00e15 	stw	r3,56(sp)
 f000d54:	d9001215 	stw	r4,72(sp)
 f000d58:	f0007440 	call	f000744 <strlen>
 f000d5c:	d9000c17 	ldw	r4,48(sp)
 f000d60:	102d883a 	mov	r22,r2
 f000d64:	20b9c83a 	sub	fp,r4,r2
 f000d68:	07001b0e 	bge	zero,fp,f000dd8 <___vfprintf_internal_r+0x66c>
 f000d6c:	00800804 	movi	r2,32
 f000d70:	d8800805 	stb	r2,32(sp)
 f000d74:	b805883a 	mov	r2,r23
 f000d78:	dc001115 	stw	r16,68(sp)
 f000d7c:	b02f883a 	mov	r23,r22
 f000d80:	e47fffc4 	addi	r17,fp,-1
 f000d84:	902d883a 	mov	r22,r18
 f000d88:	057fffc4 	movi	r21,-1
 f000d8c:	dc000f17 	ldw	r16,60(sp)
 f000d90:	1025883a 	mov	r18,r2
 f000d94:	00000206 	br	f000da0 <___vfprintf_internal_r+0x634>
 f000d98:	8c7fffc4 	addi	r17,r17,-1
 f000d9c:	8d400826 	beq	r17,r21,f000dc0 <___vfprintf_internal_r+0x654>
 f000da0:	90800117 	ldw	r2,4(r18)
 f000da4:	8009883a 	mov	r4,r16
 f000da8:	900b883a 	mov	r5,r18
 f000dac:	d9800804 	addi	r6,sp,32
 f000db0:	01c00044 	movi	r7,1
 f000db4:	103ee83a 	callr	r2
 f000db8:	103ff726 	beq	r2,zero,f000d98 <_gp+0xffff75bc>
 f000dbc:	003f3c06 	br	f000ab0 <_gp+0xffff72d4>
 f000dc0:	dc001117 	ldw	r16,68(sp)
 f000dc4:	9005883a 	mov	r2,r18
 f000dc8:	b025883a 	mov	r18,r22
 f000dcc:	9725883a 	add	r18,r18,fp
 f000dd0:	b82d883a 	mov	r22,r23
 f000dd4:	102f883a 	mov	r23,r2
 f000dd8:	b8800117 	ldw	r2,4(r23)
 f000ddc:	d9000f17 	ldw	r4,60(sp)
 f000de0:	d9801217 	ldw	r6,72(sp)
 f000de4:	b80b883a 	mov	r5,r23
 f000de8:	b00f883a 	mov	r7,r22
 f000dec:	103ee83a 	callr	r2
 f000df0:	103f2f1e 	bne	r2,zero,f000ab0 <_gp+0xffff72d4>
 f000df4:	95a5883a 	add	r18,r18,r22
 f000df8:	002b883a 	mov	r21,zero
 f000dfc:	003e7606 	br	f0007d8 <_gp+0xffff6ffc>
 f000e00:	95a5883a 	add	r18,r18,r22
 f000e04:	d9400e17 	ldw	r5,56(sp)
 f000e08:	b8800117 	ldw	r2,4(r23)
 f000e0c:	d9000f17 	ldw	r4,60(sp)
 f000e10:	28c00017 	ldw	r3,0(r5)
 f000e14:	d9800904 	addi	r6,sp,36
 f000e18:	b80b883a 	mov	r5,r23
 f000e1c:	d8c00905 	stb	r3,36(sp)
 f000e20:	d8c00e17 	ldw	r3,56(sp)
 f000e24:	01c00044 	movi	r7,1
 f000e28:	1c400104 	addi	r17,r3,4
 f000e2c:	103ee83a 	callr	r2
 f000e30:	103f1f1e 	bne	r2,zero,f000ab0 <_gp+0xffff72d4>
 f000e34:	94800044 	addi	r18,r18,1
 f000e38:	dc400e15 	stw	r17,56(sp)
 f000e3c:	002b883a 	mov	r21,zero
 f000e40:	003e6506 	br	f0007d8 <_gp+0xffff6ffc>
 f000e44:	b8800117 	ldw	r2,4(r23)
 f000e48:	d9000f17 	ldw	r4,60(sp)
 f000e4c:	00c00b44 	movi	r3,45
 f000e50:	d8c00905 	stb	r3,36(sp)
 f000e54:	b80b883a 	mov	r5,r23
 f000e58:	d9800904 	addi	r6,sp,36
 f000e5c:	01c00044 	movi	r7,1
 f000e60:	103ee83a 	callr	r2
 f000e64:	103f121e 	bne	r2,zero,f000ab0 <_gp+0xffff72d4>
 f000e68:	d8c01117 	ldw	r3,68(sp)
 f000e6c:	94800044 	addi	r18,r18,1
 f000e70:	00fefc16 	blt	zero,r3,f000a64 <_gp+0xffff7288>
 f000e74:	003f5d06 	br	f000bec <_gp+0xffff7410>
 f000e78:	056bc83a 	sub	r21,zero,r21
 f000e7c:	d8c01215 	stw	r3,72(sp)
 f000e80:	003f1406 	br	f000ad4 <_gp+0xffff72f8>
 f000e84:	d8c01117 	ldw	r3,68(sp)
 f000e88:	8805883a 	mov	r2,r17
 f000e8c:	dc001217 	ldw	r16,72(sp)
 f000e90:	b823883a 	mov	r17,r23
 f000e94:	90e5883a 	add	r18,r18,r3
 f000e98:	102f883a 	mov	r23,r2
 f000e9c:	003f5306 	br	f000bec <_gp+0xffff7410>

0f000ea0 <__vfprintf_internal>:
 f000ea0:	0083c034 	movhi	r2,3840
 f000ea4:	1085f804 	addi	r2,r2,6112
 f000ea8:	2007883a 	mov	r3,r4
 f000eac:	11000017 	ldw	r4,0(r2)
 f000eb0:	2805883a 	mov	r2,r5
 f000eb4:	300f883a 	mov	r7,r6
 f000eb8:	180b883a 	mov	r5,r3
 f000ebc:	100d883a 	mov	r6,r2
 f000ec0:	f00076c1 	jmpi	f00076c <___vfprintf_internal_r>

0f000ec4 <__sfvwrite_small_dev>:
 f000ec4:	2880000b 	ldhu	r2,0(r5)
 f000ec8:	defffa04 	addi	sp,sp,-24
 f000ecc:	dcc00315 	stw	r19,12(sp)
 f000ed0:	10c0020c 	andi	r3,r2,8
 f000ed4:	18ffffcc 	andi	r3,r3,65535
 f000ed8:	18e0001c 	xori	r3,r3,32768
 f000edc:	dc800215 	stw	r18,8(sp)
 f000ee0:	dc400115 	stw	r17,4(sp)
 f000ee4:	dfc00515 	stw	ra,20(sp)
 f000ee8:	dd000415 	stw	r20,16(sp)
 f000eec:	dc000015 	stw	r16,0(sp)
 f000ef0:	18e00004 	addi	r3,r3,-32768
 f000ef4:	2825883a 	mov	r18,r5
 f000ef8:	2027883a 	mov	r19,r4
 f000efc:	3023883a 	mov	r17,r6
 f000f00:	18002626 	beq	r3,zero,f000f9c <__sfvwrite_small_dev+0xd8>
 f000f04:	2940008f 	ldh	r5,2(r5)
 f000f08:	28001016 	blt	r5,zero,f000f4c <__sfvwrite_small_dev+0x88>
 f000f0c:	01c01a0e 	bge	zero,r7,f000f78 <__sfvwrite_small_dev+0xb4>
 f000f10:	3821883a 	mov	r16,r7
 f000f14:	05010004 	movi	r20,1024
 f000f18:	00000306 	br	f000f28 <__sfvwrite_small_dev+0x64>
 f000f1c:	88a3883a 	add	r17,r17,r2
 f000f20:	0400150e 	bge	zero,r16,f000f78 <__sfvwrite_small_dev+0xb4>
 f000f24:	9140008f 	ldh	r5,2(r18)
 f000f28:	880d883a 	mov	r6,r17
 f000f2c:	9809883a 	mov	r4,r19
 f000f30:	800f883a 	mov	r7,r16
 f000f34:	a400010e 	bge	r20,r16,f000f3c <__sfvwrite_small_dev+0x78>
 f000f38:	01c10004 	movi	r7,1024
 f000f3c:	f0010600 	call	f001060 <_write_r>
 f000f40:	80a1c83a 	sub	r16,r16,r2
 f000f44:	00bff516 	blt	zero,r2,f000f1c <_gp+0xffff7740>
 f000f48:	9080000b 	ldhu	r2,0(r18)
 f000f4c:	10801014 	ori	r2,r2,64
 f000f50:	9080000d 	sth	r2,0(r18)
 f000f54:	00bfffc4 	movi	r2,-1
 f000f58:	dfc00517 	ldw	ra,20(sp)
 f000f5c:	dd000417 	ldw	r20,16(sp)
 f000f60:	dcc00317 	ldw	r19,12(sp)
 f000f64:	dc800217 	ldw	r18,8(sp)
 f000f68:	dc400117 	ldw	r17,4(sp)
 f000f6c:	dc000017 	ldw	r16,0(sp)
 f000f70:	dec00604 	addi	sp,sp,24
 f000f74:	f800283a 	ret
 f000f78:	0005883a 	mov	r2,zero
 f000f7c:	dfc00517 	ldw	ra,20(sp)
 f000f80:	dd000417 	ldw	r20,16(sp)
 f000f84:	dcc00317 	ldw	r19,12(sp)
 f000f88:	dc800217 	ldw	r18,8(sp)
 f000f8c:	dc400117 	ldw	r17,4(sp)
 f000f90:	dc000017 	ldw	r16,0(sp)
 f000f94:	dec00604 	addi	sp,sp,24
 f000f98:	f800283a 	ret
 f000f9c:	00bfffc4 	movi	r2,-1
 f000fa0:	003fed06 	br	f000f58 <_gp+0xffff777c>

0f000fa4 <putc>:
 f000fa4:	defffd04 	addi	sp,sp,-12
 f000fa8:	0083c034 	movhi	r2,3840
 f000fac:	1085f804 	addi	r2,r2,6112
 f000fb0:	dc000115 	stw	r16,4(sp)
 f000fb4:	2021883a 	mov	r16,r4
 f000fb8:	11000017 	ldw	r4,0(r2)
 f000fbc:	dfc00215 	stw	ra,8(sp)
 f000fc0:	0083c034 	movhi	r2,3840
 f000fc4:	1083b104 	addi	r2,r2,3780
 f000fc8:	28800115 	stw	r2,4(r5)
 f000fcc:	d80d883a 	mov	r6,sp
 f000fd0:	01c00044 	movi	r7,1
 f000fd4:	dc000005 	stb	r16,0(sp)
 f000fd8:	103ee83a 	callr	r2
 f000fdc:	00ffffc4 	movi	r3,-1
 f000fe0:	10c00526 	beq	r2,r3,f000ff8 <putc+0x54>
 f000fe4:	8005883a 	mov	r2,r16
 f000fe8:	dfc00217 	ldw	ra,8(sp)
 f000fec:	dc000117 	ldw	r16,4(sp)
 f000ff0:	dec00304 	addi	sp,sp,12
 f000ff4:	f800283a 	ret
 f000ff8:	1021883a 	mov	r16,r2
 f000ffc:	003ff906 	br	f000fe4 <_gp+0xffff7808>

0f001000 <_putc_r>:
 f001000:	0083c034 	movhi	r2,3840
 f001004:	1085f804 	addi	r2,r2,6112
 f001008:	defffd04 	addi	sp,sp,-12
 f00100c:	11000017 	ldw	r4,0(r2)
 f001010:	dc000115 	stw	r16,4(sp)
 f001014:	dfc00215 	stw	ra,8(sp)
 f001018:	0083c034 	movhi	r2,3840
 f00101c:	1083b104 	addi	r2,r2,3780
 f001020:	2821883a 	mov	r16,r5
 f001024:	30800115 	stw	r2,4(r6)
 f001028:	300b883a 	mov	r5,r6
 f00102c:	01c00044 	movi	r7,1
 f001030:	d80d883a 	mov	r6,sp
 f001034:	dc000005 	stb	r16,0(sp)
 f001038:	103ee83a 	callr	r2
 f00103c:	00ffffc4 	movi	r3,-1
 f001040:	10c00526 	beq	r2,r3,f001058 <_putc_r+0x58>
 f001044:	8005883a 	mov	r2,r16
 f001048:	dfc00217 	ldw	ra,8(sp)
 f00104c:	dc000117 	ldw	r16,4(sp)
 f001050:	dec00304 	addi	sp,sp,12
 f001054:	f800283a 	ret
 f001058:	1021883a 	mov	r16,r2
 f00105c:	003ff906 	br	f001044 <_gp+0xffff7868>

0f001060 <_write_r>:
 f001060:	defffd04 	addi	sp,sp,-12
 f001064:	dc400115 	stw	r17,4(sp)
 f001068:	dc000015 	stw	r16,0(sp)
 f00106c:	2023883a 	mov	r17,r4
 f001070:	0403c034 	movhi	r16,3840
 f001074:	84063704 	addi	r16,r16,6364
 f001078:	2809883a 	mov	r4,r5
 f00107c:	300b883a 	mov	r5,r6
 f001080:	380d883a 	mov	r6,r7
 f001084:	dfc00215 	stw	ra,8(sp)
 f001088:	80000015 	stw	zero,0(r16)
 f00108c:	f00132c0 	call	f00132c <write>
 f001090:	00ffffc4 	movi	r3,-1
 f001094:	10c00526 	beq	r2,r3,f0010ac <_write_r+0x4c>
 f001098:	dfc00217 	ldw	ra,8(sp)
 f00109c:	dc400117 	ldw	r17,4(sp)
 f0010a0:	dc000017 	ldw	r16,0(sp)
 f0010a4:	dec00304 	addi	sp,sp,12
 f0010a8:	f800283a 	ret
 f0010ac:	80c00017 	ldw	r3,0(r16)
 f0010b0:	183ff926 	beq	r3,zero,f001098 <_gp+0xffff78bc>
 f0010b4:	88c00015 	stw	r3,0(r17)
 f0010b8:	dfc00217 	ldw	ra,8(sp)
 f0010bc:	dc400117 	ldw	r17,4(sp)
 f0010c0:	dc000017 	ldw	r16,0(sp)
 f0010c4:	dec00304 	addi	sp,sp,12
 f0010c8:	f800283a 	ret

0f0010cc <udivmodsi4>:
 f0010cc:	2005883a 	mov	r2,r4
 f0010d0:	2900182e 	bgeu	r5,r4,f001134 <udivmodsi4+0x68>
 f0010d4:	28001716 	blt	r5,zero,f001134 <udivmodsi4+0x68>
 f0010d8:	01000804 	movi	r4,32
 f0010dc:	00c00044 	movi	r3,1
 f0010e0:	00000206 	br	f0010ec <udivmodsi4+0x20>
 f0010e4:	20001126 	beq	r4,zero,f00112c <udivmodsi4+0x60>
 f0010e8:	28000516 	blt	r5,zero,f001100 <udivmodsi4+0x34>
 f0010ec:	294b883a 	add	r5,r5,r5
 f0010f0:	213fffc4 	addi	r4,r4,-1
 f0010f4:	18c7883a 	add	r3,r3,r3
 f0010f8:	28bffa36 	bltu	r5,r2,f0010e4 <_gp+0xffff7908>
 f0010fc:	18000b26 	beq	r3,zero,f00112c <udivmodsi4+0x60>
 f001100:	0009883a 	mov	r4,zero
 f001104:	11400236 	bltu	r2,r5,f001110 <udivmodsi4+0x44>
 f001108:	1145c83a 	sub	r2,r2,r5
 f00110c:	20c8b03a 	or	r4,r4,r3
 f001110:	1806d07a 	srli	r3,r3,1
 f001114:	280ad07a 	srli	r5,r5,1
 f001118:	183ffa1e 	bne	r3,zero,f001104 <_gp+0xffff7928>
 f00111c:	3000021e 	bne	r6,zero,f001128 <udivmodsi4+0x5c>
 f001120:	2005883a 	mov	r2,r4
 f001124:	f800283a 	ret
 f001128:	f800283a 	ret
 f00112c:	0009883a 	mov	r4,zero
 f001130:	003ffa06 	br	f00111c <_gp+0xffff7940>
 f001134:	00c00044 	movi	r3,1
 f001138:	0009883a 	mov	r4,zero
 f00113c:	003ff106 	br	f001104 <_gp+0xffff7928>

0f001140 <__divsi3>:
 f001140:	defffe04 	addi	sp,sp,-8
 f001144:	dfc00115 	stw	ra,4(sp)
 f001148:	dc000015 	stw	r16,0(sp)
 f00114c:	20000a16 	blt	r4,zero,f001178 <__divsi3+0x38>
 f001150:	0021883a 	mov	r16,zero
 f001154:	28000b16 	blt	r5,zero,f001184 <__divsi3+0x44>
 f001158:	000d883a 	mov	r6,zero
 f00115c:	f0010cc0 	call	f0010cc <udivmodsi4>
 f001160:	80000126 	beq	r16,zero,f001168 <__divsi3+0x28>
 f001164:	0085c83a 	sub	r2,zero,r2
 f001168:	dfc00117 	ldw	ra,4(sp)
 f00116c:	dc000017 	ldw	r16,0(sp)
 f001170:	dec00204 	addi	sp,sp,8
 f001174:	f800283a 	ret
 f001178:	0109c83a 	sub	r4,zero,r4
 f00117c:	04000044 	movi	r16,1
 f001180:	283ff50e 	bge	r5,zero,f001158 <_gp+0xffff797c>
 f001184:	014bc83a 	sub	r5,zero,r5
 f001188:	8400005c 	xori	r16,r16,1
 f00118c:	003ff206 	br	f001158 <_gp+0xffff797c>

0f001190 <__modsi3>:
 f001190:	deffff04 	addi	sp,sp,-4
 f001194:	dfc00015 	stw	ra,0(sp)
 f001198:	20000516 	blt	r4,zero,f0011b0 <__modsi3+0x20>
 f00119c:	28000c16 	blt	r5,zero,f0011d0 <__modsi3+0x40>
 f0011a0:	01800044 	movi	r6,1
 f0011a4:	dfc00017 	ldw	ra,0(sp)
 f0011a8:	dec00104 	addi	sp,sp,4
 f0011ac:	f0010cc1 	jmpi	f0010cc <udivmodsi4>
 f0011b0:	0109c83a 	sub	r4,zero,r4
 f0011b4:	28000b16 	blt	r5,zero,f0011e4 <__modsi3+0x54>
 f0011b8:	01800044 	movi	r6,1
 f0011bc:	f0010cc0 	call	f0010cc <udivmodsi4>
 f0011c0:	0085c83a 	sub	r2,zero,r2
 f0011c4:	dfc00017 	ldw	ra,0(sp)
 f0011c8:	dec00104 	addi	sp,sp,4
 f0011cc:	f800283a 	ret
 f0011d0:	014bc83a 	sub	r5,zero,r5
 f0011d4:	01800044 	movi	r6,1
 f0011d8:	dfc00017 	ldw	ra,0(sp)
 f0011dc:	dec00104 	addi	sp,sp,4
 f0011e0:	f0010cc1 	jmpi	f0010cc <udivmodsi4>
 f0011e4:	014bc83a 	sub	r5,zero,r5
 f0011e8:	003ff306 	br	f0011b8 <_gp+0xffff79dc>

0f0011ec <__udivsi3>:
 f0011ec:	000d883a 	mov	r6,zero
 f0011f0:	f0010cc1 	jmpi	f0010cc <udivmodsi4>

0f0011f4 <__umodsi3>:
 f0011f4:	01800044 	movi	r6,1
 f0011f8:	f0010cc1 	jmpi	f0010cc <udivmodsi4>

0f0011fc <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 f0011fc:	deffff04 	addi	sp,sp,-4
 f001200:	dfc00015 	stw	ra,0(sp)
 f001204:	00c3c034 	movhi	r3,3840
 f001208:	18c5bf04 	addi	r3,r3,5884
 f00120c:	0103c034 	movhi	r4,3840
 f001210:	2105fb04 	addi	r4,r4,6124

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 f001214:	1900061e 	bne	r3,r4,f001230 <alt_load+0x34>
 f001218:	00c3c034 	movhi	r3,3840
 f00121c:	18c00804 	addi	r3,r3,32
 f001220:	0103c034 	movhi	r4,3840
 f001224:	21000804 	addi	r4,r4,32
 f001228:	1900151e 	bne	r3,r4,f001280 <alt_load+0x84>
 f00122c:	00000e06 	br	f001268 <alt_load+0x6c>
 * alt_load() is called when the code is executing from flash. In this case
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
 f001230:	0143c034 	movhi	r5,3840
 f001234:	2945fb04 	addi	r5,r5,6124
 f001238:	00bfff04 	movi	r2,-4
 f00123c:	28cbc83a 	sub	r5,r5,r3
 f001240:	288a703a 	and	r5,r5,r2
 f001244:	0005883a 	mov	r2,zero
 f001248:	00000506 	br	f001260 <alt_load+0x64>
 f00124c:	208f883a 	add	r7,r4,r2
  {
    while( to != end )
    {
      *to++ = *from++;
 f001250:	39c00017 	ldw	r7,0(r7)
 f001254:	188d883a 	add	r6,r3,r2
 f001258:	10800104 	addi	r2,r2,4
 f00125c:	31c00015 	stw	r7,0(r6)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 f001260:	117ffa1e 	bne	r2,r5,f00124c <_gp+0xffff7a70>
 f001264:	003fec06 	br	f001218 <_gp+0xffff7a3c>
 f001268:	00c3c034 	movhi	r3,3840
 f00126c:	18c53404 	addi	r3,r3,5328
 f001270:	0103c034 	movhi	r4,3840
 f001274:	21053404 	addi	r4,r4,5328

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 f001278:	1900131e 	bne	r3,r4,f0012c8 <alt_load+0xcc>
 f00127c:	00000e06 	br	f0012b8 <alt_load+0xbc>
 f001280:	0143c034 	movhi	r5,3840
 f001284:	29400804 	addi	r5,r5,32
 f001288:	00bfff04 	movi	r2,-4
 f00128c:	28cbc83a 	sub	r5,r5,r3
 f001290:	288a703a 	and	r5,r5,r2
 f001294:	0005883a 	mov	r2,zero
 f001298:	00000506 	br	f0012b0 <alt_load+0xb4>
 f00129c:	208f883a 	add	r7,r4,r2
  {
    while( to != end )
    {
      *to++ = *from++;
 f0012a0:	39c00017 	ldw	r7,0(r7)
 f0012a4:	188d883a 	add	r6,r3,r2
 f0012a8:	10800104 	addi	r2,r2,4
 f0012ac:	31c00015 	stw	r7,0(r6)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 f0012b0:	117ffa1e 	bne	r2,r5,f00129c <_gp+0xffff7ac0>
 f0012b4:	003fec06 	br	f001268 <_gp+0xffff7a8c>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 f0012b8:	f0014c00 	call	f0014c0 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
 f0012bc:	dfc00017 	ldw	ra,0(sp)
 f0012c0:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
 f0012c4:	f0014c41 	jmpi	f0014c4 <alt_icache_flush_all>
 * alt_load() is called when the code is executing from flash. In this case
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
 f0012c8:	0143c034 	movhi	r5,3840
 f0012cc:	2945bf04 	addi	r5,r5,5884
 f0012d0:	00bfff04 	movi	r2,-4
 f0012d4:	28cbc83a 	sub	r5,r5,r3
 f0012d8:	288a703a 	and	r5,r5,r2
 f0012dc:	0005883a 	mov	r2,zero
 f0012e0:	00000506 	br	f0012f8 <alt_load+0xfc>
 f0012e4:	208f883a 	add	r7,r4,r2
    {
      *to++ = *from++;
 f0012e8:	39c00017 	ldw	r7,0(r7)
 f0012ec:	188d883a 	add	r6,r3,r2
 f0012f0:	10800104 	addi	r2,r2,4
 f0012f4:	31c00015 	stw	r7,0(r6)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 f0012f8:	117ffa1e 	bne	r2,r5,f0012e4 <_gp+0xffff7b08>
 f0012fc:	003fee06 	br	f0012b8 <_gp+0xffff7adc>

0f001300 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 f001300:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 f001304:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 f001308:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 f00130c:	f0013940 	call	f001394 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 f001310:	f0013b40 	call	f0013b4 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 f001314:	d1204317 	ldw	r4,-32500(gp)
 f001318:	d1604217 	ldw	r5,-32504(gp)
 f00131c:	d1a04117 	ldw	r6,-32508(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
 f001320:	dfc00017 	ldw	ra,0(sp)
 f001324:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 f001328:	f00005c1 	jmpi	f00005c <main>

0f00132c <write>:
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 f00132c:	deffff04 	addi	sp,sp,-4
 f001330:	dfc00015 	stw	ra,0(sp)
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
 f001334:	00800044 	movi	r2,1
 f001338:	20800226 	beq	r4,r2,f001344 <write+0x18>
 f00133c:	00800084 	movi	r2,2
 f001340:	2080061e 	bne	r4,r2,f00135c <write+0x30>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
 f001344:	0103c034 	movhi	r4,3840
 f001348:	2105f904 	addi	r4,r4,6116
 f00134c:	000f883a 	mov	r7,zero
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
        return -1;
    }
}
 f001350:	dfc00017 	ldw	ra,0(sp)
 f001354:	dec00104 	addi	sp,sp,4
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
 f001358:	f0013b81 	jmpi	f0013b8 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
 f00135c:	0083c034 	movhi	r2,3840
 f001360:	1085fa04 	addi	r2,r2,6120
 f001364:	10800017 	ldw	r2,0(r2)
 f001368:	10000226 	beq	r2,zero,f001374 <write+0x48>
 f00136c:	103ee83a 	callr	r2
 f001370:	00000206 	br	f00137c <write+0x50>
 f001374:	0083c034 	movhi	r2,3840
 f001378:	10863704 	addi	r2,r2,6364
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
 f00137c:	00c01444 	movi	r3,81
 f001380:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
 f001384:	00bfffc4 	movi	r2,-1
 f001388:	dfc00017 	ldw	ra,0(sp)
 f00138c:	dec00104 	addi	sp,sp,4
 f001390:	f800283a 	ret

0f001394 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 f001394:	deffff04 	addi	sp,sp,-4
 f001398:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2_E, nios2_e);
 f00139c:	f0014c80 	call	f0014c8 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 f0013a0:	00800044 	movi	r2,1
 f0013a4:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 f0013a8:	dfc00017 	ldw	ra,0(sp)
 f0013ac:	dec00104 	addi	sp,sp,4
 f0013b0:	f800283a 	ret

0f0013b4 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 f0013b4:	f800283a 	ret

0f0013b8 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
 f0013b8:	20c00017 	ldw	r3,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 f0013bc:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
 f0013c0:	2989883a 	add	r4,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
 f0013c4:	19800104 	addi	r6,r3,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
 f0013c8:	00000606 	br	f0013e4 <altera_avalon_jtag_uart_write+0x2c>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
 f0013cc:	31c00037 	ldwio	r7,0(r6)
 f0013d0:	39ffffec 	andhi	r7,r7,65535
 f0013d4:	383ffd26 	beq	r7,zero,f0013cc <_gp+0xffff7bf0>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
 f0013d8:	29c00007 	ldb	r7,0(r5)
 f0013dc:	29400044 	addi	r5,r5,1
 f0013e0:	19c00035 	stwio	r7,0(r3)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
 f0013e4:	293ff936 	bltu	r5,r4,f0013cc <_gp+0xffff7bf0>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
}
 f0013e8:	f800283a 	ret

0f0013ec <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
 f0013ec:	d8800017 	ldw	r2,0(sp)
 f0013f0:	da000117 	ldw	r8,4(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
 f0013f4:	00c00044 	movi	r3,1

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
 f0013f8:	da400217 	ldw	r9,8(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
 f0013fc:	194a983a 	sll	r5,r3,r5
int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
  const alt_u8 * write_end = write_data + write_length;
 f001400:	399f883a 	add	r15,r7,r6
  alt_u8 * read_end = read_data + read_length;
 f001404:	409d883a 	add	r14,r8,r2
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
 f001408:	21400535 	stwio	r5,20(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
 f00140c:	48c0008c 	andi	r3,r9,2
 f001410:	1800021e 	bne	r3,zero,f00141c <alt_avalon_spi_command+0x30>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
 f001414:	00c10004 	movi	r3,1024
 f001418:	20c00335 	stwio	r3,12(r4)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
 f00141c:	20c00037 	ldwio	r3,0(r4)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
 f001420:	00c00044 	movi	r3,1
                           alt_u32 flags)
{
  const alt_u8 * write_end = write_data + write_length;
  alt_u8 * read_end = read_data + read_length;

  alt_u32 write_zeros = read_length;
 f001424:	100b883a 	mov	r5,r2
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 f001428:	22800204 	addi	r10,r4,8
      if (write_data < write_end)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
      else if (write_zeros > 0)
      {
        write_zeros--;
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
 f00142c:	22c00104 	addi	r11,r4,4
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 f001430:	53000037 	ldwio	r12,0(r10)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 f001434:	6340100c 	andi	r13,r12,64
 f001438:	6300200c 	andi	r12,r12,128
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
 f00143c:	68000126 	beq	r13,zero,f001444 <alt_avalon_spi_command+0x58>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 f001440:	1800021e 	bne	r3,zero,f00144c <alt_avalon_spi_command+0x60>
 f001444:	603ffa26 	beq	r12,zero,f001430 <_gp+0xffff7c54>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
 f001448:	68000c26 	beq	r13,zero,f00147c <alt_avalon_spi_command+0x90>
 f00144c:	00c00b0e 	bge	zero,r3,f00147c <alt_avalon_spi_command+0x90>
    {
      credits--;
 f001450:	18ffffc4 	addi	r3,r3,-1

      if (write_data < write_end)
 f001454:	3bc0042e 	bgeu	r7,r15,f001468 <alt_avalon_spi_command+0x7c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
 f001458:	3b400003 	ldbu	r13,0(r7)
 f00145c:	39c00044 	addi	r7,r7,1
 f001460:	5b400035 	stwio	r13,0(r11)
 f001464:	00000506 	br	f00147c <alt_avalon_spi_command+0x90>
      else if (write_zeros > 0)
 f001468:	28000326 	beq	r5,zero,f001478 <alt_avalon_spi_command+0x8c>
      {
        write_zeros--;
 f00146c:	297fffc4 	addi	r5,r5,-1
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
 f001470:	58000035 	stwio	zero,0(r11)
 f001474:	00000106 	br	f00147c <alt_avalon_spi_command+0x90>
      }
      else
        credits = -1024;
 f001478:	00ff0004 	movi	r3,-1024
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
 f00147c:	603fec26 	beq	r12,zero,f001430 <_gp+0xffff7c54>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
 f001480:	23000037 	ldwio	r12,0(r4)

      if (read_ignore > 0)
 f001484:	30000226 	beq	r6,zero,f001490 <alt_avalon_spi_command+0xa4>
        read_ignore--;
 f001488:	31bfffc4 	addi	r6,r6,-1
 f00148c:	00000206 	br	f001498 <alt_avalon_spi_command+0xac>
      else
        *read_data++ = (alt_u8)rxdata;
 f001490:	43000005 	stb	r12,0(r8)
 f001494:	42000044 	addi	r8,r8,1
      credits++;
 f001498:	18c00044 	addi	r3,r3,1

      if (read_ignore == 0 && read_data == read_end)
 f00149c:	303fe41e 	bne	r6,zero,f001430 <_gp+0xffff7c54>
 f0014a0:	43bfe31e 	bne	r8,r14,f001430 <_gp+0xffff7c54>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 f0014a4:	50c00037 	ldwio	r3,0(r10)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
 f0014a8:	18c0080c 	andi	r3,r3,32
 f0014ac:	183ffd26 	beq	r3,zero,f0014a4 <_gp+0xffff7cc8>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
 f0014b0:	4a40004c 	andi	r9,r9,1
 f0014b4:	4800011e 	bne	r9,zero,f0014bc <alt_avalon_spi_command+0xd0>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
 f0014b8:	20000335 	stwio	zero,12(r4)

  return read_length;
}
 f0014bc:	f800283a 	ret

0f0014c0 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 f0014c0:	f800283a 	ret

0f0014c4 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 f0014c4:	f800283a 	ret

0f0014c8 <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
 f0014c8:	000170fa 	wrctl	ienable,zero
 f0014cc:	f800283a 	ret
